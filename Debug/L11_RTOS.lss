
L11_RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000f14  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000054  00800060  00000f14  00000fa8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000025b  008000b4  008000b4  00000ffc  2**0
                  ALLOC
  3 .stab         00000750  00000000  00000000  00000ffc  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000010b  00000000  00000000  0000174c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      0000002f  00000000  00000000  00001857  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00000358  00000000  00000000  00001886  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00003953  00000000  00000000  00001bde  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000dfc  00000000  00000000  00005531  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00001408  00000000  00000000  0000632d  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000008f4  00000000  00000000  00007738  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000128d  00000000  00000000  0000802c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00003b8a  00000000  00000000  000092b9  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000368  00000000  00000000  0000ce43  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:

#include "Dio_Interface.h"

void Dio_ConfigChannel(Dio_Port port,Dio_Channel channel, Dio_Direction direction)
{
	switch (port)
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
	{
	case DIO_PORTA:
		if (direction == INPUT)
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
		{
			CLEAR_BIT(DIO_DDRA_REG,channel);
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 ed 03 	jmp	0x7da	; 0x7da <__vector_7>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
		}
		else
		{
			SET_BIT(DIO_DDRA_REG,channel);
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
		}
		break;
	case DIO_PORTB:
		if (direction == INPUT)
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
		{
			CLEAR_BIT(DIO_DDRB_REG,channel);
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e4 e1       	ldi	r30, 0x14	; 20
  68:	ff e0       	ldi	r31, 0x0F	; 15
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
		}
		else
		{
			SET_BIT(DIO_DDRB_REG,channel);
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a4 3b       	cpi	r26, 0xB4	; 180
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	23 e0       	ldi	r18, 0x03	; 3
  78:	a4 eb       	ldi	r26, 0xB4	; 180
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	af 30       	cpi	r26, 0x0F	; 15
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
		}
		break;
	case DIO_PORTC:
		if (direction == INPUT)
  86:	0e 94 57 00 	call	0xae	; 0xae <main>
		{
			CLEAR_BIT(DIO_DDRC_REG,channel);
  8a:	0c 94 88 07 	jmp	0xf10	; 0xf10 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <Task_1>:
  92:	80 e6       	ldi	r24, 0x60	; 96
  94:	90 e0       	ldi	r25, 0x00	; 0
  96:	0e 94 93 00 	call	0x126	; 0x126 <UART_TransmitStr>
  9a:	fb cf       	rjmp	.-10     	; 0x92 <Task_1>

0000009c <Task_2>:
  9c:	8a e7       	ldi	r24, 0x7A	; 122
  9e:	90 e0       	ldi	r25, 0x00	; 0
  a0:	0e 94 93 00 	call	0x126	; 0x126 <UART_TransmitStr>
  a4:	84 ef       	ldi	r24, 0xF4	; 244
		}
		else
		{
			SET_BIT(DIO_DDRC_REG,channel);
  a6:	91 e0       	ldi	r25, 0x01	; 1
  a8:	0e 94 0a 07 	call	0xe14	; 0xe14 <vTaskDelay>
  ac:	f7 cf       	rjmp	.-18     	; 0x9c <Task_2>

000000ae <main>:
  ae:	87 e6       	ldi	r24, 0x67	; 103
  b0:	90 e0       	ldi	r25, 0x00	; 0
  b2:	0e 94 87 00 	call	0x10e	; 0x10e <UART_Init>
  b6:	84 e9       	ldi	r24, 0x94	; 148
  b8:	90 e0       	ldi	r25, 0x00	; 0
  ba:	0e 94 93 00 	call	0x126	; 0x126 <UART_TransmitStr>
  be:	2f ef       	ldi	r18, 0xFF	; 255
		}
		break;
	case DIO_PORTD:
		if (direction == INPUT)
  c0:	87 ea       	ldi	r24, 0xA7	; 167
  c2:	91 e6       	ldi	r25, 0x61	; 97
		{
			CLEAR_BIT(DIO_DDRD_REG,channel);
  c4:	21 50       	subi	r18, 0x01	; 1
  c6:	80 40       	sbci	r24, 0x00	; 0
  c8:	90 40       	sbci	r25, 0x00	; 0
  ca:	e1 f7       	brne	.-8      	; 0xc4 <main+0x16>
  cc:	00 c0       	rjmp	.+0      	; 0xce <main+0x20>
  ce:	00 00       	nop
  d0:	a1 2c       	mov	r10, r1
  d2:	b1 2c       	mov	r11, r1
  d4:	c1 2c       	mov	r12, r1
  d6:	d1 2c       	mov	r13, r1
  d8:	e1 2c       	mov	r14, r1
  da:	f1 2c       	mov	r15, r1
  dc:	01 e0       	ldi	r16, 0x01	; 1
  de:	20 e6       	ldi	r18, 0x60	; 96
		}
		else
		{
			SET_BIT(DIO_DDRD_REG,channel);
  e0:	30 e0       	ldi	r19, 0x00	; 0
  e2:	44 e6       	ldi	r20, 0x64	; 100
  e4:	50 e0       	ldi	r21, 0x00	; 0
  e6:	63 ea       	ldi	r22, 0xA3	; 163
  e8:	70 e0       	ldi	r23, 0x00	; 0
  ea:	89 e4       	ldi	r24, 0x49	; 73
  ec:	90 e0       	ldi	r25, 0x00	; 0
  ee:	0e 94 46 04 	call	0x88c	; 0x88c <xTaskGenericCreate>
  f2:	02 e0       	ldi	r16, 0x02	; 2
  f4:	2a e7       	ldi	r18, 0x7A	; 122
  f6:	30 e0       	ldi	r19, 0x00	; 0
  f8:	44 e6       	ldi	r20, 0x64	; 100
	_delay_ms(2000);
	
	/*	Create Task 1	*/
	xTaskCreate(Task_1, "Task1",100,(u8*) pcTextForTask1,1,NULL);
	/*	Create Task 2	*/
	xTaskCreate(Task_2, "Task2",100,(u8*) pcTextForTask2,2,NULL);
  fa:	50 e0       	ldi	r21, 0x00	; 0
  fc:	69 ea       	ldi	r22, 0xA9	; 169
  fe:	70 e0       	ldi	r23, 0x00	; 0
 100:	8e e4       	ldi	r24, 0x4E	; 78
 102:	90 e0       	ldi	r25, 0x00	; 0
 104:	0e 94 46 04 	call	0x88c	; 0x88c <xTaskGenericCreate>
	
	/*our tasks start executing. */
	vTaskStartScheduler();
 108:	0e 94 56 05 	call	0xaac	; 0xaac <vTaskStartScheduler>
 10c:	ff cf       	rjmp	.-2      	; 0x10c <main+0x5e>

0000010e <UART_Init>:
#include "Uart_Interface.h"

void UART_Init(u16 baudRate)
{
	/* Set baud rate */
	UART_UBRRH_REG = (u8)(baudRate>>8);
 10e:	90 bd       	out	0x20, r25	; 32
	UART_UBRRL_REG = (u8)baudRate;
 110:	89 b9       	out	0x09, r24	; 9
	/* Enable receiver and transmitter */
	SET_BIT(UART_UCSRB_REG,RXEN_BIT_NO);  /* Enable Receiver*/
 112:	54 9a       	sbi	0x0a, 4	; 10
	SET_BIT(UART_UCSRB_REG,TXEN_BIT_NO);  /* Enable Transmitter */
 114:	53 9a       	sbi	0x0a, 3	; 10
	/* Set frame format: 8data, 1stop bit, Even Parity */
	UART_UCSRC_REG |= (1 << URSEL_BIT_NO)|UART_8_BIT_DATA | UART_EVEN_PARITY;
 116:	80 b5       	in	r24, 0x20	; 32
 118:	86 6a       	ori	r24, 0xA6	; 166
 11a:	80 bd       	out	0x20, r24	; 32
 11c:	08 95       	ret

0000011e <UART_TransmitChr>:
}

void UART_TransmitChr(u8 data)
{
	/* Wait for empty transmit buffer */
		while (!(CHECK_BIT(UART_UCSRA_REG,UDRE_BIT_NO)))
 11e:	5d 9b       	sbis	0x0b, 5	; 11
 120:	fe cf       	rjmp	.-4      	; 0x11e <UART_TransmitChr>
				;
		/* Put data into buffer, sends the data */
		UART_UDR_REG = data;
 122:	8c b9       	out	0x0c, r24	; 12
 124:	08 95       	ret

00000126 <UART_TransmitStr>:
}

void UART_TransmitStr(u8 *str)
{
 126:	cf 93       	push	r28
 128:	df 93       	push	r29
 12a:	ec 01       	movw	r28, r24
	/* Wait for empty transmit buffer */
	while (*str != '\0')
 12c:	88 81       	ld	r24, Y
 12e:	88 23       	and	r24, r24
 130:	31 f0       	breq	.+12     	; 0x13e <UART_TransmitStr+0x18>
				;
		/* Put data into buffer, sends the data */
		UART_UDR_REG = data;
}

void UART_TransmitStr(u8 *str)
 132:	21 96       	adiw	r28, 0x01	; 1
{
	/* Wait for empty transmit buffer */
	while (*str != '\0')
	{
		UART_TransmitChr(*str);
 134:	0e 94 8f 00 	call	0x11e	; 0x11e <UART_TransmitChr>
}

void UART_TransmitStr(u8 *str)
{
	/* Wait for empty transmit buffer */
	while (*str != '\0')
 138:	89 91       	ld	r24, Y+
 13a:	81 11       	cpse	r24, r1
 13c:	fb cf       	rjmp	.-10     	; 0x134 <UART_TransmitStr+0xe>
	{
		UART_TransmitChr(*str);
		str++;
	}
}
 13e:	df 91       	pop	r29
 140:	cf 91       	pop	r28
 142:	08 95       	ret

00000144 <prvInsertBlockIntoFreeList>:
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 144:	cf 93       	push	r28
 146:	df 93       	push	r29
 148:	ec 01       	movw	r28, r24
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 14a:	aa eb       	ldi	r26, 0xBA	; 186
 14c:	b0 e0       	ldi	r27, 0x00	; 0
 14e:	01 c0       	rjmp	.+2      	; 0x152 <prvInsertBlockIntoFreeList+0xe>
 150:	df 01       	movw	r26, r30
 152:	ed 91       	ld	r30, X+
 154:	fc 91       	ld	r31, X
 156:	11 97       	sbiw	r26, 0x01	; 1
 158:	ec 17       	cp	r30, r28
 15a:	fd 07       	cpc	r31, r29
 15c:	c8 f3       	brcs	.-14     	; 0x150 <prvInsertBlockIntoFreeList+0xc>
 15e:	cd 01       	movw	r24, r26
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 160:	12 96       	adiw	r26, 0x02	; 2
 162:	2d 91       	ld	r18, X+
 164:	3c 91       	ld	r19, X
 166:	13 97       	sbiw	r26, 0x03	; 3
 168:	ad 01       	movw	r20, r26
 16a:	42 0f       	add	r20, r18
 16c:	53 1f       	adc	r21, r19
 16e:	4c 17       	cp	r20, r28
 170:	5d 07       	cpc	r21, r29
 172:	51 f4       	brne	.+20     	; 0x188 <prvInsertBlockIntoFreeList+0x44>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 174:	ea 01       	movw	r28, r20
 176:	4a 81       	ldd	r20, Y+2	; 0x02
 178:	5b 81       	ldd	r21, Y+3	; 0x03
 17a:	24 0f       	add	r18, r20
 17c:	35 1f       	adc	r19, r21
 17e:	13 96       	adiw	r26, 0x03	; 3
 180:	3c 93       	st	X, r19
 182:	2e 93       	st	-X, r18
 184:	12 97       	sbiw	r26, 0x02	; 2
 186:	ed 01       	movw	r28, r26
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 188:	2a 81       	ldd	r18, Y+2	; 0x02
 18a:	3b 81       	ldd	r19, Y+3	; 0x03
 18c:	ae 01       	movw	r20, r28
 18e:	42 0f       	add	r20, r18
 190:	53 1f       	adc	r21, r19
 192:	e4 17       	cp	r30, r20
 194:	f5 07       	cpc	r31, r21
 196:	c1 f4       	brne	.+48     	; 0x1c8 <prvInsertBlockIntoFreeList+0x84>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 198:	40 91 b4 00 	lds	r20, 0x00B4
 19c:	50 91 b5 00 	lds	r21, 0x00B5
 1a0:	4e 17       	cp	r20, r30
 1a2:	5f 07       	cpc	r21, r31
 1a4:	71 f0       	breq	.+28     	; 0x1c2 <prvInsertBlockIntoFreeList+0x7e>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 1a6:	42 81       	ldd	r20, Z+2	; 0x02
 1a8:	53 81       	ldd	r21, Z+3	; 0x03
 1aa:	24 0f       	add	r18, r20
 1ac:	35 1f       	adc	r19, r21
 1ae:	3b 83       	std	Y+3, r19	; 0x03
 1b0:	2a 83       	std	Y+2, r18	; 0x02
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 1b2:	dc 01       	movw	r26, r24
 1b4:	ed 91       	ld	r30, X+
 1b6:	fc 91       	ld	r31, X
 1b8:	20 81       	ld	r18, Z
 1ba:	31 81       	ldd	r19, Z+1	; 0x01
 1bc:	39 83       	std	Y+1, r19	; 0x01
 1be:	28 83       	st	Y, r18
 1c0:	05 c0       	rjmp	.+10     	; 0x1cc <prvInsertBlockIntoFreeList+0x88>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
 1c2:	f9 83       	std	Y+1, r31	; 0x01
 1c4:	e8 83       	st	Y, r30
 1c6:	02 c0       	rjmp	.+4      	; 0x1cc <prvInsertBlockIntoFreeList+0x88>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 1c8:	f9 83       	std	Y+1, r31	; 0x01
 1ca:	e8 83       	st	Y, r30

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 1cc:	8c 17       	cp	r24, r28
 1ce:	9d 07       	cpc	r25, r29
 1d0:	19 f0       	breq	.+6      	; 0x1d8 <prvInsertBlockIntoFreeList+0x94>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 1d2:	fc 01       	movw	r30, r24
 1d4:	d1 83       	std	Z+1, r29	; 0x01
 1d6:	c0 83       	st	Z, r28
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 1d8:	df 91       	pop	r29
 1da:	cf 91       	pop	r28
 1dc:	08 95       	ret

000001de <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 1de:	cf 92       	push	r12
 1e0:	df 92       	push	r13
 1e2:	ef 92       	push	r14
 1e4:	ff 92       	push	r15
 1e6:	0f 93       	push	r16
 1e8:	1f 93       	push	r17
 1ea:	cf 93       	push	r28
 1ec:	df 93       	push	r29
 1ee:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
 1f0:	0e 94 88 05 	call	0xb10	; 0xb10 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
 1f4:	80 91 b4 00 	lds	r24, 0x00B4
 1f8:	90 91 b5 00 	lds	r25, 0x00B5
 1fc:	89 2b       	or	r24, r25
 1fe:	51 f5       	brne	.+84     	; 0x254 <pvPortMalloc+0x76>

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 200:	a0 ec       	ldi	r26, 0xC0	; 192
 202:	b0 e0       	ldi	r27, 0x00	; 0
 204:	b0 93 bb 00 	sts	0x00BB, r27
 208:	a0 93 ba 00 	sts	0x00BA, r26
	xStart.xBlockSize = ( size_t ) 0;
 20c:	10 92 bd 00 	sts	0x00BD, r1
 210:	10 92 bc 00 	sts	0x00BC, r1

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
	uxAddress -= xHeapStructSize;
 214:	e0 eb       	ldi	r30, 0xB0	; 176
 216:	f2 e0       	ldi	r31, 0x02	; 2
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
	pxEnd = ( void * ) uxAddress;
 218:	f0 93 b5 00 	sts	0x00B5, r31
 21c:	e0 93 b4 00 	sts	0x00B4, r30
	pxEnd->xBlockSize = 0;
 220:	13 82       	std	Z+3, r1	; 0x03
 222:	12 82       	std	Z+2, r1	; 0x02
	pxEnd->pxNextFreeBlock = NULL;
 224:	11 82       	std	Z+1, r1	; 0x01
 226:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 228:	80 ef       	ldi	r24, 0xF0	; 240
 22a:	91 e0       	ldi	r25, 0x01	; 1
 22c:	90 93 c3 00 	sts	0x00C3, r25
 230:	80 93 c2 00 	sts	0x00C2, r24
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 234:	ed 93       	st	X+, r30
 236:	fc 93       	st	X, r31

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 238:	90 93 bf 00 	sts	0x00BF, r25
 23c:	80 93 be 00 	sts	0x00BE, r24
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 240:	90 93 b9 00 	sts	0x00B9, r25
 244:	80 93 b8 00 	sts	0x00B8, r24

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 248:	80 e0       	ldi	r24, 0x00	; 0
 24a:	90 e8       	ldi	r25, 0x80	; 128
 24c:	90 93 b7 00 	sts	0x00B7, r25
 250:	80 93 b6 00 	sts	0x00B6, r24

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 254:	00 91 b6 00 	lds	r16, 0x00B6
 258:	10 91 b7 00 	lds	r17, 0x00B7
 25c:	ce 01       	movw	r24, r28
 25e:	80 23       	and	r24, r16
 260:	91 23       	and	r25, r17
 262:	89 2b       	or	r24, r25
 264:	09 f0       	breq	.+2      	; 0x268 <pvPortMalloc+0x8a>
 266:	62 c0       	rjmp	.+196    	; 0x32c <pvPortMalloc+0x14e>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
 268:	20 97       	sbiw	r28, 0x00	; 0
 26a:	09 f4       	brne	.+2      	; 0x26e <pvPortMalloc+0x90>
 26c:	62 c0       	rjmp	.+196    	; 0x332 <pvPortMalloc+0x154>
			{
				xWantedSize += xHeapStructSize;
 26e:	ae 01       	movw	r20, r28
 270:	4c 5f       	subi	r20, 0xFC	; 252
 272:	5f 4f       	sbci	r21, 0xFF	; 255
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 274:	09 f4       	brne	.+2      	; 0x278 <pvPortMalloc+0x9a>
 276:	60 c0       	rjmp	.+192    	; 0x338 <pvPortMalloc+0x15a>
 278:	e0 90 b8 00 	lds	r14, 0x00B8
 27c:	f0 90 b9 00 	lds	r15, 0x00B9
 280:	e4 16       	cp	r14, r20
 282:	f5 06       	cpc	r15, r21
 284:	08 f4       	brcc	.+2      	; 0x288 <pvPortMalloc+0xaa>
 286:	5b c0       	rjmp	.+182    	; 0x33e <pvPortMalloc+0x160>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
 288:	c0 91 ba 00 	lds	r28, 0x00BA
 28c:	d0 91 bb 00 	lds	r29, 0x00BB

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
 290:	ea eb       	ldi	r30, 0xBA	; 186
 292:	f0 e0       	ldi	r31, 0x00	; 0
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 294:	03 c0       	rjmp	.+6      	; 0x29c <pvPortMalloc+0xbe>
 296:	e9 2f       	mov	r30, r25
 298:	f8 2f       	mov	r31, r24
				{
					pxPreviousBlock = pxBlock;
					pxBlock = pxBlock->pxNextFreeBlock;
 29a:	e9 01       	movw	r28, r18
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 29c:	2a 81       	ldd	r18, Y+2	; 0x02
 29e:	3b 81       	ldd	r19, Y+3	; 0x03
 2a0:	24 17       	cp	r18, r20
 2a2:	35 07       	cpc	r19, r21
 2a4:	38 f4       	brcc	.+14     	; 0x2b4 <pvPortMalloc+0xd6>
 2a6:	28 81       	ld	r18, Y
 2a8:	39 81       	ldd	r19, Y+1	; 0x01
 2aa:	9c 2f       	mov	r25, r28
 2ac:	8d 2f       	mov	r24, r29
 2ae:	21 15       	cp	r18, r1
 2b0:	31 05       	cpc	r19, r1
 2b2:	89 f7       	brne	.-30     	; 0x296 <pvPortMalloc+0xb8>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
 2b4:	80 91 b4 00 	lds	r24, 0x00B4
 2b8:	90 91 b5 00 	lds	r25, 0x00B5
 2bc:	c8 17       	cp	r28, r24
 2be:	d9 07       	cpc	r29, r25
 2c0:	09 f4       	brne	.+2      	; 0x2c4 <pvPortMalloc+0xe6>
 2c2:	40 c0       	rjmp	.+128    	; 0x344 <pvPortMalloc+0x166>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 2c4:	c0 80       	ld	r12, Z
 2c6:	d1 80       	ldd	r13, Z+1	; 0x01
 2c8:	84 e0       	ldi	r24, 0x04	; 4
 2ca:	c8 0e       	add	r12, r24
 2cc:	d1 1c       	adc	r13, r1

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 2ce:	88 81       	ld	r24, Y
 2d0:	99 81       	ldd	r25, Y+1	; 0x01
 2d2:	91 83       	std	Z+1, r25	; 0x01
 2d4:	80 83       	st	Z, r24

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 2d6:	2a 81       	ldd	r18, Y+2	; 0x02
 2d8:	3b 81       	ldd	r19, Y+3	; 0x03
 2da:	24 1b       	sub	r18, r20
 2dc:	35 0b       	sbc	r19, r21
 2de:	29 30       	cpi	r18, 0x09	; 9
 2e0:	31 05       	cpc	r19, r1
 2e2:	50 f0       	brcs	.+20     	; 0x2f8 <pvPortMalloc+0x11a>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 2e4:	ce 01       	movw	r24, r28
 2e6:	84 0f       	add	r24, r20
 2e8:	95 1f       	adc	r25, r21
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 2ea:	fc 01       	movw	r30, r24
 2ec:	33 83       	std	Z+3, r19	; 0x03
 2ee:	22 83       	std	Z+2, r18	; 0x02
						pxBlock->xBlockSize = xWantedSize;
 2f0:	5b 83       	std	Y+3, r21	; 0x03
 2f2:	4a 83       	std	Y+2, r20	; 0x02

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 2f4:	0e 94 a2 00 	call	0x144	; 0x144 <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
 2f8:	8a 81       	ldd	r24, Y+2	; 0x02
 2fa:	9b 81       	ldd	r25, Y+3	; 0x03
 2fc:	e8 1a       	sub	r14, r24
 2fe:	f9 0a       	sbc	r15, r25
 300:	f0 92 b9 00 	sts	0x00B9, r15
 304:	e0 92 b8 00 	sts	0x00B8, r14

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 308:	20 91 be 00 	lds	r18, 0x00BE
 30c:	30 91 bf 00 	lds	r19, 0x00BF
 310:	e2 16       	cp	r14, r18
 312:	f3 06       	cpc	r15, r19
 314:	20 f4       	brcc	.+8      	; 0x31e <pvPortMalloc+0x140>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 316:	f0 92 bf 00 	sts	0x00BF, r15
 31a:	e0 92 be 00 	sts	0x00BE, r14
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 31e:	08 2b       	or	r16, r24
 320:	19 2b       	or	r17, r25
 322:	1b 83       	std	Y+3, r17	; 0x03
 324:	0a 83       	std	Y+2, r16	; 0x02
					pxBlock->pxNextFreeBlock = NULL;
 326:	19 82       	std	Y+1, r1	; 0x01
 328:	18 82       	st	Y, r1
 32a:	0e c0       	rjmp	.+28     	; 0x348 <pvPortMalloc+0x16a>
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
 32c:	c1 2c       	mov	r12, r1
 32e:	d1 2c       	mov	r13, r1
 330:	0b c0       	rjmp	.+22     	; 0x348 <pvPortMalloc+0x16a>
 332:	c1 2c       	mov	r12, r1
 334:	d1 2c       	mov	r13, r1
 336:	08 c0       	rjmp	.+16     	; 0x348 <pvPortMalloc+0x16a>
 338:	c1 2c       	mov	r12, r1
 33a:	d1 2c       	mov	r13, r1
 33c:	05 c0       	rjmp	.+10     	; 0x348 <pvPortMalloc+0x16a>
 33e:	c1 2c       	mov	r12, r1
 340:	d1 2c       	mov	r13, r1
 342:	02 c0       	rjmp	.+4      	; 0x348 <pvPortMalloc+0x16a>
 344:	c1 2c       	mov	r12, r1
 346:	d1 2c       	mov	r13, r1
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 348:	0e 94 4d 06 	call	0xc9a	; 0xc9a <xTaskResumeAll>
	}
	#endif

	configASSERT( ( ( ( uint32_t ) pvReturn ) & portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
 34c:	8c 2d       	mov	r24, r12
 34e:	9d 2d       	mov	r25, r13
 350:	df 91       	pop	r29
 352:	cf 91       	pop	r28
 354:	1f 91       	pop	r17
 356:	0f 91       	pop	r16
 358:	ff 90       	pop	r15
 35a:	ef 90       	pop	r14
 35c:	df 90       	pop	r13
 35e:	cf 90       	pop	r12
 360:	08 95       	ret

00000362 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 362:	cf 93       	push	r28
 364:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
 366:	00 97       	sbiw	r24, 0x00	; 0
 368:	69 f1       	breq	.+90     	; 0x3c4 <vPortFree+0x62>

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
		configASSERT( pxLink->pxNextFreeBlock == NULL );

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
 36a:	fc 01       	movw	r30, r24
 36c:	34 97       	sbiw	r30, 0x04	; 4
 36e:	22 81       	ldd	r18, Z+2	; 0x02
 370:	33 81       	ldd	r19, Z+3	; 0x03
 372:	40 91 b6 00 	lds	r20, 0x00B6
 376:	50 91 b7 00 	lds	r21, 0x00B7
 37a:	ba 01       	movw	r22, r20
 37c:	62 23       	and	r22, r18
 37e:	73 23       	and	r23, r19
 380:	67 2b       	or	r22, r23
 382:	01 f1       	breq	.+64     	; 0x3c4 <vPortFree+0x62>
		{
			if( pxLink->pxNextFreeBlock == NULL )
 384:	fc 01       	movw	r30, r24
 386:	34 97       	sbiw	r30, 0x04	; 4
 388:	60 81       	ld	r22, Z
 38a:	71 81       	ldd	r23, Z+1	; 0x01
 38c:	67 2b       	or	r22, r23
 38e:	d1 f4       	brne	.+52     	; 0x3c4 <vPortFree+0x62>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 390:	ef 01       	movw	r28, r30
 392:	40 95       	com	r20
 394:	50 95       	com	r21
 396:	24 23       	and	r18, r20
 398:	35 23       	and	r19, r21
 39a:	33 83       	std	Z+3, r19	; 0x03
 39c:	22 83       	std	Z+2, r18	; 0x02

				vTaskSuspendAll();
 39e:	0e 94 88 05 	call	0xb10	; 0xb10 <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
 3a2:	20 91 b8 00 	lds	r18, 0x00B8
 3a6:	30 91 b9 00 	lds	r19, 0x00B9
 3aa:	8a 81       	ldd	r24, Y+2	; 0x02
 3ac:	9b 81       	ldd	r25, Y+3	; 0x03
 3ae:	82 0f       	add	r24, r18
 3b0:	93 1f       	adc	r25, r19
 3b2:	90 93 b9 00 	sts	0x00B9, r25
 3b6:	80 93 b8 00 	sts	0x00B8, r24
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 3ba:	ce 01       	movw	r24, r28
 3bc:	0e 94 a2 00 	call	0x144	; 0x144 <prvInsertBlockIntoFreeList>
				}
				( void ) xTaskResumeAll();
 3c0:	0e 94 4d 06 	call	0xc9a	; 0xc9a <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
 3c4:	df 91       	pop	r29
 3c6:	cf 91       	pop	r28
 3c8:	08 95       	ret

000003ca <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 3ca:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 3cc:	03 96       	adiw	r24, 0x03	; 3
 3ce:	92 83       	std	Z+2, r25	; 0x02
 3d0:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 3d2:	2f ef       	ldi	r18, 0xFF	; 255
 3d4:	3f ef       	ldi	r19, 0xFF	; 255
 3d6:	34 83       	std	Z+4, r19	; 0x04
 3d8:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 3da:	96 83       	std	Z+6, r25	; 0x06
 3dc:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 3de:	90 87       	std	Z+8, r25	; 0x08
 3e0:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 3e2:	10 82       	st	Z, r1
 3e4:	08 95       	ret

000003e6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 3e6:	fc 01       	movw	r30, r24
 3e8:	11 86       	std	Z+9, r1	; 0x09
 3ea:	10 86       	std	Z+8, r1	; 0x08
 3ec:	08 95       	ret

000003ee <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 3ee:	cf 93       	push	r28
 3f0:	df 93       	push	r29
 3f2:	9c 01       	movw	r18, r24
 3f4:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
 3f6:	dc 01       	movw	r26, r24
 3f8:	11 96       	adiw	r26, 0x01	; 1
 3fa:	cd 91       	ld	r28, X+
 3fc:	dc 91       	ld	r29, X
 3fe:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 400:	d3 83       	std	Z+3, r29	; 0x03
 402:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 404:	8c 81       	ldd	r24, Y+4	; 0x04
 406:	9d 81       	ldd	r25, Y+5	; 0x05
 408:	95 83       	std	Z+5, r25	; 0x05
 40a:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 40c:	8c 81       	ldd	r24, Y+4	; 0x04
 40e:	9d 81       	ldd	r25, Y+5	; 0x05
 410:	dc 01       	movw	r26, r24
 412:	13 96       	adiw	r26, 0x03	; 3
 414:	7c 93       	st	X, r23
 416:	6e 93       	st	-X, r22
 418:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
 41a:	7d 83       	std	Y+5, r23	; 0x05
 41c:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 41e:	31 87       	std	Z+9, r19	; 0x09
 420:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
 422:	f9 01       	movw	r30, r18
 424:	80 81       	ld	r24, Z
 426:	8f 5f       	subi	r24, 0xFF	; 255
 428:	80 83       	st	Z, r24
}
 42a:	df 91       	pop	r29
 42c:	cf 91       	pop	r28
 42e:	08 95       	ret

00000430 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 430:	cf 93       	push	r28
 432:	df 93       	push	r29
 434:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 436:	48 81       	ld	r20, Y
 438:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 43a:	4f 3f       	cpi	r20, 0xFF	; 255
 43c:	2f ef       	ldi	r18, 0xFF	; 255
 43e:	52 07       	cpc	r21, r18
 440:	21 f4       	brne	.+8      	; 0x44a <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 442:	fc 01       	movw	r30, r24
 444:	a7 81       	ldd	r26, Z+7	; 0x07
 446:	b0 85       	ldd	r27, Z+8	; 0x08
 448:	0d c0       	rjmp	.+26     	; 0x464 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 44a:	dc 01       	movw	r26, r24
 44c:	13 96       	adiw	r26, 0x03	; 3
 44e:	01 c0       	rjmp	.+2      	; 0x452 <vListInsert+0x22>
 450:	df 01       	movw	r26, r30
 452:	12 96       	adiw	r26, 0x02	; 2
 454:	ed 91       	ld	r30, X+
 456:	fc 91       	ld	r31, X
 458:	13 97       	sbiw	r26, 0x03	; 3
 45a:	20 81       	ld	r18, Z
 45c:	31 81       	ldd	r19, Z+1	; 0x01
 45e:	42 17       	cp	r20, r18
 460:	53 07       	cpc	r21, r19
 462:	b0 f7       	brcc	.-20     	; 0x450 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 464:	12 96       	adiw	r26, 0x02	; 2
 466:	ed 91       	ld	r30, X+
 468:	fc 91       	ld	r31, X
 46a:	13 97       	sbiw	r26, 0x03	; 3
 46c:	fb 83       	std	Y+3, r31	; 0x03
 46e:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 470:	d5 83       	std	Z+5, r29	; 0x05
 472:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
 474:	bd 83       	std	Y+5, r27	; 0x05
 476:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
 478:	13 96       	adiw	r26, 0x03	; 3
 47a:	dc 93       	st	X, r29
 47c:	ce 93       	st	-X, r28
 47e:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 480:	99 87       	std	Y+9, r25	; 0x09
 482:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
 484:	fc 01       	movw	r30, r24
 486:	20 81       	ld	r18, Z
 488:	2f 5f       	subi	r18, 0xFF	; 255
 48a:	20 83       	st	Z, r18
}
 48c:	df 91       	pop	r29
 48e:	cf 91       	pop	r28
 490:	08 95       	ret

00000492 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 492:	cf 93       	push	r28
 494:	df 93       	push	r29
 496:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 498:	a0 85       	ldd	r26, Z+8	; 0x08
 49a:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 49c:	c2 81       	ldd	r28, Z+2	; 0x02
 49e:	d3 81       	ldd	r29, Z+3	; 0x03
 4a0:	84 81       	ldd	r24, Z+4	; 0x04
 4a2:	95 81       	ldd	r25, Z+5	; 0x05
 4a4:	9d 83       	std	Y+5, r25	; 0x05
 4a6:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 4a8:	c4 81       	ldd	r28, Z+4	; 0x04
 4aa:	d5 81       	ldd	r29, Z+5	; 0x05
 4ac:	82 81       	ldd	r24, Z+2	; 0x02
 4ae:	93 81       	ldd	r25, Z+3	; 0x03
 4b0:	9b 83       	std	Y+3, r25	; 0x03
 4b2:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 4b4:	11 96       	adiw	r26, 0x01	; 1
 4b6:	cd 91       	ld	r28, X+
 4b8:	dc 91       	ld	r29, X
 4ba:	12 97       	sbiw	r26, 0x02	; 2
 4bc:	ce 17       	cp	r28, r30
 4be:	df 07       	cpc	r29, r31
 4c0:	31 f4       	brne	.+12     	; 0x4ce <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 4c2:	8c 81       	ldd	r24, Y+4	; 0x04
 4c4:	9d 81       	ldd	r25, Y+5	; 0x05
 4c6:	12 96       	adiw	r26, 0x02	; 2
 4c8:	9c 93       	st	X, r25
 4ca:	8e 93       	st	-X, r24
 4cc:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 4ce:	11 86       	std	Z+9, r1	; 0x09
 4d0:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 4d2:	8c 91       	ld	r24, X
 4d4:	81 50       	subi	r24, 0x01	; 1
 4d6:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
 4d8:	df 91       	pop	r29
 4da:	cf 91       	pop	r28
 4dc:	08 95       	ret

000004de <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
 4de:	31 e1       	ldi	r19, 0x11	; 17
 4e0:	fc 01       	movw	r30, r24
 4e2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
 4e4:	31 97       	sbiw	r30, 0x01	; 1
 4e6:	22 e2       	ldi	r18, 0x22	; 34
 4e8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
 4ea:	fc 01       	movw	r30, r24
 4ec:	32 97       	sbiw	r30, 0x02	; 2
 4ee:	a3 e3       	ldi	r26, 0x33	; 51
 4f0:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
 4f2:	fc 01       	movw	r30, r24
 4f4:	33 97       	sbiw	r30, 0x03	; 3
 4f6:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
 4f8:	fc 01       	movw	r30, r24
 4fa:	34 97       	sbiw	r30, 0x04	; 4
 4fc:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
 4fe:	fc 01       	movw	r30, r24
 500:	35 97       	sbiw	r30, 0x05	; 5
 502:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
 504:	fc 01       	movw	r30, r24
 506:	36 97       	sbiw	r30, 0x06	; 6
 508:	60 e8       	ldi	r22, 0x80	; 128
 50a:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
 50c:	fc 01       	movw	r30, r24
 50e:	37 97       	sbiw	r30, 0x07	; 7
 510:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
 512:	fc 01       	movw	r30, r24
 514:	38 97       	sbiw	r30, 0x08	; 8
 516:	62 e0       	ldi	r22, 0x02	; 2
 518:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
 51a:	fc 01       	movw	r30, r24
 51c:	39 97       	sbiw	r30, 0x09	; 9
 51e:	63 e0       	ldi	r22, 0x03	; 3
 520:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
 522:	fc 01       	movw	r30, r24
 524:	3a 97       	sbiw	r30, 0x0a	; 10
 526:	64 e0       	ldi	r22, 0x04	; 4
 528:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
 52a:	fc 01       	movw	r30, r24
 52c:	3b 97       	sbiw	r30, 0x0b	; 11
 52e:	65 e0       	ldi	r22, 0x05	; 5
 530:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
 532:	fc 01       	movw	r30, r24
 534:	3c 97       	sbiw	r30, 0x0c	; 12
 536:	66 e0       	ldi	r22, 0x06	; 6
 538:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
 53a:	fc 01       	movw	r30, r24
 53c:	3d 97       	sbiw	r30, 0x0d	; 13
 53e:	67 e0       	ldi	r22, 0x07	; 7
 540:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
 542:	fc 01       	movw	r30, r24
 544:	3e 97       	sbiw	r30, 0x0e	; 14
 546:	68 e0       	ldi	r22, 0x08	; 8
 548:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
 54a:	fc 01       	movw	r30, r24
 54c:	3f 97       	sbiw	r30, 0x0f	; 15
 54e:	69 e0       	ldi	r22, 0x09	; 9
 550:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
 552:	fc 01       	movw	r30, r24
 554:	70 97       	sbiw	r30, 0x10	; 16
 556:	60 e1       	ldi	r22, 0x10	; 16
 558:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
 55a:	fc 01       	movw	r30, r24
 55c:	71 97       	sbiw	r30, 0x11	; 17
 55e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
 560:	fc 01       	movw	r30, r24
 562:	72 97       	sbiw	r30, 0x12	; 18
 564:	32 e1       	ldi	r19, 0x12	; 18
 566:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
 568:	fc 01       	movw	r30, r24
 56a:	73 97       	sbiw	r30, 0x13	; 19
 56c:	33 e1       	ldi	r19, 0x13	; 19
 56e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
 570:	fc 01       	movw	r30, r24
 572:	74 97       	sbiw	r30, 0x14	; 20
 574:	34 e1       	ldi	r19, 0x14	; 20
 576:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
 578:	fc 01       	movw	r30, r24
 57a:	75 97       	sbiw	r30, 0x15	; 21
 57c:	35 e1       	ldi	r19, 0x15	; 21
 57e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
 580:	fc 01       	movw	r30, r24
 582:	76 97       	sbiw	r30, 0x16	; 22
 584:	36 e1       	ldi	r19, 0x16	; 22
 586:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
 588:	fc 01       	movw	r30, r24
 58a:	77 97       	sbiw	r30, 0x17	; 23
 58c:	37 e1       	ldi	r19, 0x17	; 23
 58e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
 590:	fc 01       	movw	r30, r24
 592:	78 97       	sbiw	r30, 0x18	; 24
 594:	38 e1       	ldi	r19, 0x18	; 24
 596:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
 598:	fc 01       	movw	r30, r24
 59a:	79 97       	sbiw	r30, 0x19	; 25
 59c:	39 e1       	ldi	r19, 0x19	; 25
 59e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
 5a0:	fc 01       	movw	r30, r24
 5a2:	7a 97       	sbiw	r30, 0x1a	; 26
 5a4:	30 e2       	ldi	r19, 0x20	; 32
 5a6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
 5a8:	fc 01       	movw	r30, r24
 5aa:	7b 97       	sbiw	r30, 0x1b	; 27
 5ac:	31 e2       	ldi	r19, 0x21	; 33
 5ae:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
 5b0:	fc 01       	movw	r30, r24
 5b2:	7c 97       	sbiw	r30, 0x1c	; 28
 5b4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
 5b6:	fc 01       	movw	r30, r24
 5b8:	7d 97       	sbiw	r30, 0x1d	; 29
 5ba:	23 e2       	ldi	r18, 0x23	; 35
 5bc:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
 5be:	fc 01       	movw	r30, r24
 5c0:	7e 97       	sbiw	r30, 0x1e	; 30
 5c2:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
 5c4:	fc 01       	movw	r30, r24
 5c6:	7f 97       	sbiw	r30, 0x1f	; 31
 5c8:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
 5ca:	fc 01       	movw	r30, r24
 5cc:	b0 97       	sbiw	r30, 0x20	; 32
 5ce:	26 e2       	ldi	r18, 0x26	; 38
 5d0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
 5d2:	fc 01       	movw	r30, r24
 5d4:	b1 97       	sbiw	r30, 0x21	; 33
 5d6:	27 e2       	ldi	r18, 0x27	; 39
 5d8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
 5da:	fc 01       	movw	r30, r24
 5dc:	b2 97       	sbiw	r30, 0x22	; 34
 5de:	28 e2       	ldi	r18, 0x28	; 40
 5e0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
 5e2:	fc 01       	movw	r30, r24
 5e4:	b3 97       	sbiw	r30, 0x23	; 35
 5e6:	29 e2       	ldi	r18, 0x29	; 41
 5e8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
 5ea:	fc 01       	movw	r30, r24
 5ec:	b4 97       	sbiw	r30, 0x24	; 36
 5ee:	20 e3       	ldi	r18, 0x30	; 48
 5f0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
 5f2:	fc 01       	movw	r30, r24
 5f4:	b5 97       	sbiw	r30, 0x25	; 37
 5f6:	21 e3       	ldi	r18, 0x31	; 49
 5f8:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
 5fa:	9c 01       	movw	r18, r24
 5fc:	26 52       	subi	r18, 0x26	; 38
 5fe:	31 09       	sbc	r19, r1
}
 600:	82 2f       	mov	r24, r18
 602:	93 2f       	mov	r25, r19
 604:	08 95       	ret

00000606 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
 606:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
 608:	89 ef       	ldi	r24, 0xF9	; 249
 60a:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
 60c:	8b e0       	ldi	r24, 0x0B	; 11
 60e:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
 610:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
 612:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
 614:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
 616:	a0 91 c4 02 	lds	r26, 0x02C4
 61a:	b0 91 c5 02 	lds	r27, 0x02C5
 61e:	cd 91       	ld	r28, X+
 620:	cd bf       	out	0x3d, r28	; 61
 622:	dd 91       	ld	r29, X+
 624:	de bf       	out	0x3e, r29	; 62
 626:	ff 91       	pop	r31
 628:	ef 91       	pop	r30
 62a:	df 91       	pop	r29
 62c:	cf 91       	pop	r28
 62e:	bf 91       	pop	r27
 630:	af 91       	pop	r26
 632:	9f 91       	pop	r25
 634:	8f 91       	pop	r24
 636:	7f 91       	pop	r23
 638:	6f 91       	pop	r22
 63a:	5f 91       	pop	r21
 63c:	4f 91       	pop	r20
 63e:	3f 91       	pop	r19
 640:	2f 91       	pop	r18
 642:	1f 91       	pop	r17
 644:	0f 91       	pop	r16
 646:	ff 90       	pop	r15
 648:	ef 90       	pop	r14
 64a:	df 90       	pop	r13
 64c:	cf 90       	pop	r12
 64e:	bf 90       	pop	r11
 650:	af 90       	pop	r10
 652:	9f 90       	pop	r9
 654:	8f 90       	pop	r8
 656:	7f 90       	pop	r7
 658:	6f 90       	pop	r6
 65a:	5f 90       	pop	r5
 65c:	4f 90       	pop	r4
 65e:	3f 90       	pop	r3
 660:	2f 90       	pop	r2
 662:	1f 90       	pop	r1
 664:	0f 90       	pop	r0
 666:	0f be       	out	0x3f, r0	; 63
 668:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
 66a:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
 66c:	81 e0       	ldi	r24, 0x01	; 1
 66e:	08 95       	ret

00000670 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 670:	0f 92       	push	r0
 672:	0f b6       	in	r0, 0x3f	; 63
 674:	f8 94       	cli
 676:	0f 92       	push	r0
 678:	1f 92       	push	r1
 67a:	11 24       	eor	r1, r1
 67c:	2f 92       	push	r2
 67e:	3f 92       	push	r3
 680:	4f 92       	push	r4
 682:	5f 92       	push	r5
 684:	6f 92       	push	r6
 686:	7f 92       	push	r7
 688:	8f 92       	push	r8
 68a:	9f 92       	push	r9
 68c:	af 92       	push	r10
 68e:	bf 92       	push	r11
 690:	cf 92       	push	r12
 692:	df 92       	push	r13
 694:	ef 92       	push	r14
 696:	ff 92       	push	r15
 698:	0f 93       	push	r16
 69a:	1f 93       	push	r17
 69c:	2f 93       	push	r18
 69e:	3f 93       	push	r19
 6a0:	4f 93       	push	r20
 6a2:	5f 93       	push	r21
 6a4:	6f 93       	push	r22
 6a6:	7f 93       	push	r23
 6a8:	8f 93       	push	r24
 6aa:	9f 93       	push	r25
 6ac:	af 93       	push	r26
 6ae:	bf 93       	push	r27
 6b0:	cf 93       	push	r28
 6b2:	df 93       	push	r29
 6b4:	ef 93       	push	r30
 6b6:	ff 93       	push	r31
 6b8:	a0 91 c4 02 	lds	r26, 0x02C4
 6bc:	b0 91 c5 02 	lds	r27, 0x02C5
 6c0:	0d b6       	in	r0, 0x3d	; 61
 6c2:	0d 92       	st	X+, r0
 6c4:	0e b6       	in	r0, 0x3e	; 62
 6c6:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 6c8:	0e 94 2a 07 	call	0xe54	; 0xe54 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 6cc:	a0 91 c4 02 	lds	r26, 0x02C4
 6d0:	b0 91 c5 02 	lds	r27, 0x02C5
 6d4:	cd 91       	ld	r28, X+
 6d6:	cd bf       	out	0x3d, r28	; 61
 6d8:	dd 91       	ld	r29, X+
 6da:	de bf       	out	0x3e, r29	; 62
 6dc:	ff 91       	pop	r31
 6de:	ef 91       	pop	r30
 6e0:	df 91       	pop	r29
 6e2:	cf 91       	pop	r28
 6e4:	bf 91       	pop	r27
 6e6:	af 91       	pop	r26
 6e8:	9f 91       	pop	r25
 6ea:	8f 91       	pop	r24
 6ec:	7f 91       	pop	r23
 6ee:	6f 91       	pop	r22
 6f0:	5f 91       	pop	r21
 6f2:	4f 91       	pop	r20
 6f4:	3f 91       	pop	r19
 6f6:	2f 91       	pop	r18
 6f8:	1f 91       	pop	r17
 6fa:	0f 91       	pop	r16
 6fc:	ff 90       	pop	r15
 6fe:	ef 90       	pop	r14
 700:	df 90       	pop	r13
 702:	cf 90       	pop	r12
 704:	bf 90       	pop	r11
 706:	af 90       	pop	r10
 708:	9f 90       	pop	r9
 70a:	8f 90       	pop	r8
 70c:	7f 90       	pop	r7
 70e:	6f 90       	pop	r6
 710:	5f 90       	pop	r5
 712:	4f 90       	pop	r4
 714:	3f 90       	pop	r3
 716:	2f 90       	pop	r2
 718:	1f 90       	pop	r1
 71a:	0f 90       	pop	r0
 71c:	0f be       	out	0x3f, r0	; 63
 71e:	0f 90       	pop	r0

	asm volatile ( "ret" );
 720:	08 95       	ret

00000722 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 722:	0f 92       	push	r0
 724:	0f b6       	in	r0, 0x3f	; 63
 726:	f8 94       	cli
 728:	0f 92       	push	r0
 72a:	1f 92       	push	r1
 72c:	11 24       	eor	r1, r1
 72e:	2f 92       	push	r2
 730:	3f 92       	push	r3
 732:	4f 92       	push	r4
 734:	5f 92       	push	r5
 736:	6f 92       	push	r6
 738:	7f 92       	push	r7
 73a:	8f 92       	push	r8
 73c:	9f 92       	push	r9
 73e:	af 92       	push	r10
 740:	bf 92       	push	r11
 742:	cf 92       	push	r12
 744:	df 92       	push	r13
 746:	ef 92       	push	r14
 748:	ff 92       	push	r15
 74a:	0f 93       	push	r16
 74c:	1f 93       	push	r17
 74e:	2f 93       	push	r18
 750:	3f 93       	push	r19
 752:	4f 93       	push	r20
 754:	5f 93       	push	r21
 756:	6f 93       	push	r22
 758:	7f 93       	push	r23
 75a:	8f 93       	push	r24
 75c:	9f 93       	push	r25
 75e:	af 93       	push	r26
 760:	bf 93       	push	r27
 762:	cf 93       	push	r28
 764:	df 93       	push	r29
 766:	ef 93       	push	r30
 768:	ff 93       	push	r31
 76a:	a0 91 c4 02 	lds	r26, 0x02C4
 76e:	b0 91 c5 02 	lds	r27, 0x02C5
 772:	0d b6       	in	r0, 0x3d	; 61
 774:	0d 92       	st	X+, r0
 776:	0e b6       	in	r0, 0x3e	; 62
 778:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
 77a:	0e 94 8e 05 	call	0xb1c	; 0xb1c <xTaskIncrementTick>
 77e:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
 780:	0e 94 2a 07 	call	0xe54	; 0xe54 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
 784:	a0 91 c4 02 	lds	r26, 0x02C4
 788:	b0 91 c5 02 	lds	r27, 0x02C5
 78c:	cd 91       	ld	r28, X+
 78e:	cd bf       	out	0x3d, r28	; 61
 790:	dd 91       	ld	r29, X+
 792:	de bf       	out	0x3e, r29	; 62
 794:	ff 91       	pop	r31
 796:	ef 91       	pop	r30
 798:	df 91       	pop	r29
 79a:	cf 91       	pop	r28
 79c:	bf 91       	pop	r27
 79e:	af 91       	pop	r26
 7a0:	9f 91       	pop	r25
 7a2:	8f 91       	pop	r24
 7a4:	7f 91       	pop	r23
 7a6:	6f 91       	pop	r22
 7a8:	5f 91       	pop	r21
 7aa:	4f 91       	pop	r20
 7ac:	3f 91       	pop	r19
 7ae:	2f 91       	pop	r18
 7b0:	1f 91       	pop	r17
 7b2:	0f 91       	pop	r16
 7b4:	ff 90       	pop	r15
 7b6:	ef 90       	pop	r14
 7b8:	df 90       	pop	r13
 7ba:	cf 90       	pop	r12
 7bc:	bf 90       	pop	r11
 7be:	af 90       	pop	r10
 7c0:	9f 90       	pop	r9
 7c2:	8f 90       	pop	r8
 7c4:	7f 90       	pop	r7
 7c6:	6f 90       	pop	r6
 7c8:	5f 90       	pop	r5
 7ca:	4f 90       	pop	r4
 7cc:	3f 90       	pop	r3
 7ce:	2f 90       	pop	r2
 7d0:	1f 90       	pop	r1
 7d2:	0f 90       	pop	r0
 7d4:	0f be       	out	0x3f, r0	; 63
 7d6:	0f 90       	pop	r0

	asm volatile ( "ret" );
 7d8:	08 95       	ret

000007da <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
 7da:	0e 94 91 03 	call	0x722	; 0x722 <vPortYieldFromTick>
		asm volatile ( "reti" );
 7de:	18 95       	reti

000007e0 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 7e0:	e0 91 c2 02 	lds	r30, 0x02C2
 7e4:	f0 91 c3 02 	lds	r31, 0x02C3
 7e8:	80 81       	ld	r24, Z
 7ea:	81 11       	cpse	r24, r1
 7ec:	07 c0       	rjmp	.+14     	; 0x7fc <prvResetNextTaskUnblockTime+0x1c>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 7ee:	8f ef       	ldi	r24, 0xFF	; 255
 7f0:	9f ef       	ldi	r25, 0xFF	; 255
 7f2:	90 93 b6 02 	sts	0x02B6, r25
 7f6:	80 93 b5 02 	sts	0x02B5, r24
 7fa:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 7fc:	e0 91 c2 02 	lds	r30, 0x02C2
 800:	f0 91 c3 02 	lds	r31, 0x02C3
 804:	05 80       	ldd	r0, Z+5	; 0x05
 806:	f6 81       	ldd	r31, Z+6	; 0x06
 808:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
 80a:	06 80       	ldd	r0, Z+6	; 0x06
 80c:	f7 81       	ldd	r31, Z+7	; 0x07
 80e:	e0 2d       	mov	r30, r0
 810:	82 81       	ldd	r24, Z+2	; 0x02
 812:	93 81       	ldd	r25, Z+3	; 0x03
 814:	90 93 b6 02 	sts	0x02B6, r25
 818:	80 93 b5 02 	sts	0x02B5, r24
 81c:	08 95       	ret

0000081e <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
 81e:	cf 93       	push	r28
 820:	df 93       	push	r29
 822:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 824:	e0 91 c4 02 	lds	r30, 0x02C4
 828:	f0 91 c5 02 	lds	r31, 0x02C5
 82c:	93 83       	std	Z+3, r25	; 0x03
 82e:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
 830:	80 91 bc 02 	lds	r24, 0x02BC
 834:	90 91 bd 02 	lds	r25, 0x02BD
 838:	c8 17       	cp	r28, r24
 83a:	d9 07       	cpc	r29, r25
 83c:	68 f4       	brcc	.+26     	; 0x858 <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 83e:	60 91 c4 02 	lds	r22, 0x02C4
 842:	70 91 c5 02 	lds	r23, 0x02C5
 846:	80 91 c0 02 	lds	r24, 0x02C0
 84a:	90 91 c1 02 	lds	r25, 0x02C1
 84e:	6e 5f       	subi	r22, 0xFE	; 254
 850:	7f 4f       	sbci	r23, 0xFF	; 255
 852:	0e 94 18 02 	call	0x430	; 0x430 <vListInsert>
 856:	17 c0       	rjmp	.+46     	; 0x886 <__stack+0x27>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 858:	60 91 c4 02 	lds	r22, 0x02C4
 85c:	70 91 c5 02 	lds	r23, 0x02C5
 860:	80 91 c2 02 	lds	r24, 0x02C2
 864:	90 91 c3 02 	lds	r25, 0x02C3
 868:	6e 5f       	subi	r22, 0xFE	; 254
 86a:	7f 4f       	sbci	r23, 0xFF	; 255
 86c:	0e 94 18 02 	call	0x430	; 0x430 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
 870:	80 91 b5 02 	lds	r24, 0x02B5
 874:	90 91 b6 02 	lds	r25, 0x02B6
 878:	c8 17       	cp	r28, r24
 87a:	d9 07       	cpc	r29, r25
 87c:	20 f4       	brcc	.+8      	; 0x886 <__stack+0x27>
		{
			xNextTaskUnblockTime = xTimeToWake;
 87e:	d0 93 b6 02 	sts	0x02B6, r29
 882:	c0 93 b5 02 	sts	0x02B5, r28
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
 886:	df 91       	pop	r29
 888:	cf 91       	pop	r28
 88a:	08 95       	ret

0000088c <xTaskGenericCreate>:

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 88c:	4f 92       	push	r4
 88e:	5f 92       	push	r5
 890:	6f 92       	push	r6
 892:	7f 92       	push	r7
 894:	8f 92       	push	r8
 896:	9f 92       	push	r9
 898:	af 92       	push	r10
 89a:	bf 92       	push	r11
 89c:	cf 92       	push	r12
 89e:	df 92       	push	r13
 8a0:	ef 92       	push	r14
 8a2:	ff 92       	push	r15
 8a4:	0f 93       	push	r16
 8a6:	1f 93       	push	r17
 8a8:	cf 93       	push	r28
 8aa:	df 93       	push	r29
 8ac:	4c 01       	movw	r8, r24
 8ae:	5b 01       	movw	r10, r22
 8b0:	2a 01       	movw	r4, r20
 8b2:	39 01       	movw	r6, r18
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8b4:	c1 14       	cp	r12, r1
 8b6:	d1 04       	cpc	r13, r1
 8b8:	39 f4       	brne	.+14     	; 0x8c8 <xTaskGenericCreate+0x3c>
 8ba:	ca 01       	movw	r24, r20
 8bc:	0e 94 ef 00 	call	0x1de	; 0x1de <pvPortMalloc>
 8c0:	6c 01       	movw	r12, r24

		if( pxStack != NULL )
 8c2:	00 97       	sbiw	r24, 0x00	; 0
 8c4:	09 f4       	brne	.+2      	; 0x8c8 <xTaskGenericCreate+0x3c>
 8c6:	e0 c0       	rjmp	.+448    	; 0xa88 <xTaskGenericCreate+0x1fc>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 8c8:	86 e2       	ldi	r24, 0x26	; 38
 8ca:	90 e0       	ldi	r25, 0x00	; 0
 8cc:	0e 94 ef 00 	call	0x1de	; 0x1de <pvPortMalloc>
 8d0:	ec 01       	movw	r28, r24

			if( pxNewTCB != NULL )
 8d2:	00 97       	sbiw	r24, 0x00	; 0
 8d4:	71 f0       	breq	.+28     	; 0x8f2 <xTaskGenericCreate+0x66>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
 8d6:	d8 8e       	std	Y+24, r13	; 0x18
 8d8:	cf 8a       	std	Y+23, r12	; 0x17
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
 8da:	81 e0       	ldi	r24, 0x01	; 1
 8dc:	48 1a       	sub	r4, r24
 8de:	51 08       	sbc	r5, r1
 8e0:	c4 0c       	add	r12, r4
 8e2:	d5 1c       	adc	r13, r5
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
 8e4:	d5 01       	movw	r26, r10
 8e6:	8c 91       	ld	r24, X
 8e8:	89 8f       	std	Y+25, r24	; 0x19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 8ea:	8c 91       	ld	r24, X
 8ec:	81 11       	cpse	r24, r1
 8ee:	05 c0       	rjmp	.+10     	; 0x8fa <xTaskGenericCreate+0x6e>
 8f0:	15 c0       	rjmp	.+42     	; 0x91c <xTaskGenericCreate+0x90>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
 8f2:	c6 01       	movw	r24, r12
 8f4:	0e 94 b1 01 	call	0x362	; 0x362 <vPortFree>
 8f8:	c7 c0       	rjmp	.+398    	; 0xa88 <xTaskGenericCreate+0x1fc>
	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName );

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
 8fa:	ae 01       	movw	r20, r28
 8fc:	46 5e       	subi	r20, 0xE6	; 230
 8fe:	5f 4f       	sbci	r21, 0xFF	; 255
 900:	f5 01       	movw	r30, r10
 902:	31 96       	adiw	r30, 0x01	; 1
 904:	27 e0       	ldi	r18, 0x07	; 7
 906:	cf 01       	movw	r24, r30
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
 908:	31 91       	ld	r19, Z+
 90a:	da 01       	movw	r26, r20
 90c:	3d 93       	st	X+, r19
 90e:	ad 01       	movw	r20, r26

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 910:	dc 01       	movw	r26, r24
 912:	8c 91       	ld	r24, X
 914:	88 23       	and	r24, r24
 916:	11 f0       	breq	.+4      	; 0x91c <xTaskGenericCreate+0x90>
 918:	21 50       	subi	r18, 0x01	; 1
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 91a:	a9 f7       	brne	.-22     	; 0x906 <xTaskGenericCreate+0x7a>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 91c:	18 a2       	std	Y+32, r1	; 0x20
 91e:	10 2f       	mov	r17, r16
 920:	04 30       	cpi	r16, 0x04	; 4
 922:	08 f0       	brcs	.+2      	; 0x926 <xTaskGenericCreate+0x9a>
 924:	13 e0       	ldi	r17, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
 926:	1e 8b       	std	Y+22, r17	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 928:	5e 01       	movw	r10, r28
 92a:	b2 e0       	ldi	r27, 0x02	; 2
 92c:	ab 0e       	add	r10, r27
 92e:	b1 1c       	adc	r11, r1
 930:	c5 01       	movw	r24, r10
 932:	0e 94 f3 01 	call	0x3e6	; 0x3e6 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 936:	ce 01       	movw	r24, r28
 938:	0c 96       	adiw	r24, 0x0c	; 12
 93a:	0e 94 f3 01 	call	0x3e6	; 0x3e6 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 93e:	d9 87       	std	Y+9, r29	; 0x09
 940:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 942:	84 e0       	ldi	r24, 0x04	; 4
 944:	90 e0       	ldi	r25, 0x00	; 0
 946:	81 1b       	sub	r24, r17
 948:	91 09       	sbc	r25, r1
 94a:	9d 87       	std	Y+13, r25	; 0x0d
 94c:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 94e:	db 8b       	std	Y+19, r29	; 0x13
 950:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
 952:	19 a2       	std	Y+33, r1	; 0x21
 954:	1a a2       	std	Y+34, r1	; 0x22
 956:	1b a2       	std	Y+35, r1	; 0x23
 958:	1c a2       	std	Y+36, r1	; 0x24
		pxTCB->eNotifyState = eNotWaitingNotification;
 95a:	1d a2       	std	Y+37, r1	; 0x25
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 95c:	a3 01       	movw	r20, r6
 95e:	b4 01       	movw	r22, r8
 960:	c6 01       	movw	r24, r12
 962:	0e 94 6f 02 	call	0x4de	; 0x4de <pxPortInitialiseStack>
 966:	99 83       	std	Y+1, r25	; 0x01
 968:	88 83       	st	Y, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
 96a:	e1 14       	cp	r14, r1
 96c:	f1 04       	cpc	r15, r1
 96e:	19 f0       	breq	.+6      	; 0x976 <xTaskGenericCreate+0xea>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 970:	f7 01       	movw	r30, r14
 972:	d1 83       	std	Z+1, r29	; 0x01
 974:	c0 83       	st	Z, r28
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
 976:	0f b6       	in	r0, 0x3f	; 63
 978:	f8 94       	cli
 97a:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
 97c:	80 91 be 02 	lds	r24, 0x02BE
 980:	8f 5f       	subi	r24, 0xFF	; 255
 982:	80 93 be 02 	sts	0x02BE, r24
			if( pxCurrentTCB == NULL )
 986:	80 91 c4 02 	lds	r24, 0x02C4
 98a:	90 91 c5 02 	lds	r25, 0x02C5
 98e:	89 2b       	or	r24, r25
 990:	e1 f5       	brne	.+120    	; 0xa0a <xTaskGenericCreate+0x17e>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
 992:	d0 93 c5 02 	sts	0x02C5, r29
 996:	c0 93 c4 02 	sts	0x02C4, r28

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 99a:	80 91 be 02 	lds	r24, 0x02BE
 99e:	81 30       	cpi	r24, 0x01	; 1
 9a0:	09 f0       	breq	.+2      	; 0x9a4 <xTaskGenericCreate+0x118>
 9a2:	42 c0       	rjmp	.+132    	; 0xa28 <xTaskGenericCreate+0x19c>
 9a4:	e1 2c       	mov	r14, r1
 9a6:	f1 2c       	mov	r15, r1
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 9a8:	c7 01       	movw	r24, r14
 9aa:	88 0f       	add	r24, r24
 9ac:	99 1f       	adc	r25, r25
 9ae:	88 0f       	add	r24, r24
 9b0:	99 1f       	adc	r25, r25
 9b2:	88 0f       	add	r24, r24
 9b4:	99 1f       	adc	r25, r25
 9b6:	8e 0d       	add	r24, r14
 9b8:	9f 1d       	adc	r25, r15
 9ba:	89 53       	subi	r24, 0x39	; 57
 9bc:	9d 4f       	sbci	r25, 0xFD	; 253
 9be:	0e 94 e5 01 	call	0x3ca	; 0x3ca <vListInitialise>
 9c2:	ff ef       	ldi	r31, 0xFF	; 255
 9c4:	ef 1a       	sub	r14, r31
 9c6:	ff 0a       	sbc	r15, r31

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 9c8:	84 e0       	ldi	r24, 0x04	; 4
 9ca:	e8 16       	cp	r14, r24
 9cc:	f1 04       	cpc	r15, r1
 9ce:	61 f7       	brne	.-40     	; 0x9a8 <xTaskGenericCreate+0x11c>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
 9d0:	8b ee       	ldi	r24, 0xEB	; 235
 9d2:	92 e0       	ldi	r25, 0x02	; 2
 9d4:	0e 94 e5 01 	call	0x3ca	; 0x3ca <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 9d8:	84 ef       	ldi	r24, 0xF4	; 244
 9da:	92 e0       	ldi	r25, 0x02	; 2
 9dc:	0e 94 e5 01 	call	0x3ca	; 0x3ca <vListInitialise>
	vListInitialise( &xPendingReadyList );
 9e0:	8d ef       	ldi	r24, 0xFD	; 253
 9e2:	92 e0       	ldi	r25, 0x02	; 2
 9e4:	0e 94 e5 01 	call	0x3ca	; 0x3ca <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
 9e8:	86 e0       	ldi	r24, 0x06	; 6
 9ea:	93 e0       	ldi	r25, 0x03	; 3
 9ec:	0e 94 e5 01 	call	0x3ca	; 0x3ca <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 9f0:	8b ee       	ldi	r24, 0xEB	; 235
 9f2:	92 e0       	ldi	r25, 0x02	; 2
 9f4:	90 93 c3 02 	sts	0x02C3, r25
 9f8:	80 93 c2 02 	sts	0x02C2, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 9fc:	84 ef       	ldi	r24, 0xF4	; 244
 9fe:	92 e0       	ldi	r25, 0x02	; 2
 a00:	90 93 c1 02 	sts	0x02C1, r25
 a04:	80 93 c0 02 	sts	0x02C0, r24
 a08:	0f c0       	rjmp	.+30     	; 0xa28 <xTaskGenericCreate+0x19c>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
 a0a:	80 91 ba 02 	lds	r24, 0x02BA
 a0e:	81 11       	cpse	r24, r1
 a10:	0b c0       	rjmp	.+22     	; 0xa28 <xTaskGenericCreate+0x19c>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
 a12:	e0 91 c4 02 	lds	r30, 0x02C4
 a16:	f0 91 c5 02 	lds	r31, 0x02C5
 a1a:	86 89       	ldd	r24, Z+22	; 0x16
 a1c:	08 17       	cp	r16, r24
 a1e:	20 f0       	brcs	.+8      	; 0xa28 <xTaskGenericCreate+0x19c>
					{
						pxCurrentTCB = pxNewTCB;
 a20:	d0 93 c5 02 	sts	0x02C5, r29
 a24:	c0 93 c4 02 	sts	0x02C4, r28
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
 a28:	80 91 c6 02 	lds	r24, 0x02C6
 a2c:	8f 5f       	subi	r24, 0xFF	; 255
 a2e:	80 93 c6 02 	sts	0x02C6, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
 a32:	8e 89       	ldd	r24, Y+22	; 0x16
 a34:	90 91 bb 02 	lds	r25, 0x02BB
 a38:	98 17       	cp	r25, r24
 a3a:	10 f4       	brcc	.+4      	; 0xa40 <xTaskGenericCreate+0x1b4>
 a3c:	80 93 bb 02 	sts	0x02BB, r24
 a40:	90 e0       	ldi	r25, 0x00	; 0
 a42:	9c 01       	movw	r18, r24
 a44:	22 0f       	add	r18, r18
 a46:	33 1f       	adc	r19, r19
 a48:	22 0f       	add	r18, r18
 a4a:	33 1f       	adc	r19, r19
 a4c:	22 0f       	add	r18, r18
 a4e:	33 1f       	adc	r19, r19
 a50:	82 0f       	add	r24, r18
 a52:	93 1f       	adc	r25, r19
 a54:	b5 01       	movw	r22, r10
 a56:	89 53       	subi	r24, 0x39	; 57
 a58:	9d 4f       	sbci	r25, 0xFD	; 253
 a5a:	0e 94 f7 01 	call	0x3ee	; 0x3ee <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
 a5e:	0f 90       	pop	r0
 a60:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
 a62:	80 91 ba 02 	lds	r24, 0x02BA
 a66:	88 23       	and	r24, r24
 a68:	59 f0       	breq	.+22     	; 0xa80 <xTaskGenericCreate+0x1f4>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
 a6a:	e0 91 c4 02 	lds	r30, 0x02C4
 a6e:	f0 91 c5 02 	lds	r31, 0x02C5
 a72:	86 89       	ldd	r24, Z+22	; 0x16
 a74:	80 17       	cp	r24, r16
 a76:	30 f4       	brcc	.+12     	; 0xa84 <xTaskGenericCreate+0x1f8>
			{
				taskYIELD_IF_USING_PREEMPTION();
 a78:	0e 94 38 03 	call	0x670	; 0x670 <vPortYield>
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );

			xReturn = pdPASS;
 a7c:	81 e0       	ldi	r24, 0x01	; 1
 a7e:	05 c0       	rjmp	.+10     	; 0xa8a <xTaskGenericCreate+0x1fe>
 a80:	81 e0       	ldi	r24, 0x01	; 1
 a82:	03 c0       	rjmp	.+6      	; 0xa8a <xTaskGenericCreate+0x1fe>
 a84:	81 e0       	ldi	r24, 0x01	; 1
 a86:	01 c0       	rjmp	.+2      	; 0xa8a <xTaskGenericCreate+0x1fe>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 a88:	8f ef       	ldi	r24, 0xFF	; 255
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
}
 a8a:	df 91       	pop	r29
 a8c:	cf 91       	pop	r28
 a8e:	1f 91       	pop	r17
 a90:	0f 91       	pop	r16
 a92:	ff 90       	pop	r15
 a94:	ef 90       	pop	r14
 a96:	df 90       	pop	r13
 a98:	cf 90       	pop	r12
 a9a:	bf 90       	pop	r11
 a9c:	af 90       	pop	r10
 a9e:	9f 90       	pop	r9
 aa0:	8f 90       	pop	r8
 aa2:	7f 90       	pop	r7
 aa4:	6f 90       	pop	r6
 aa6:	5f 90       	pop	r5
 aa8:	4f 90       	pop	r4
 aaa:	08 95       	ret

00000aac <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 aac:	af 92       	push	r10
 aae:	bf 92       	push	r11
 ab0:	cf 92       	push	r12
 ab2:	df 92       	push	r13
 ab4:	ef 92       	push	r14
 ab6:	ff 92       	push	r15
 ab8:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
 aba:	a1 2c       	mov	r10, r1
 abc:	b1 2c       	mov	r11, r1
 abe:	c1 2c       	mov	r12, r1
 ac0:	d1 2c       	mov	r13, r1
 ac2:	e1 2c       	mov	r14, r1
 ac4:	f1 2c       	mov	r15, r1
 ac6:	00 e0       	ldi	r16, 0x00	; 0
 ac8:	20 e0       	ldi	r18, 0x00	; 0
 aca:	30 e0       	ldi	r19, 0x00	; 0
 acc:	44 e6       	ldi	r20, 0x64	; 100
 ace:	50 e0       	ldi	r21, 0x00	; 0
 ad0:	6f ea       	ldi	r22, 0xAF	; 175
 ad2:	70 e0       	ldi	r23, 0x00	; 0
 ad4:	8e ec       	ldi	r24, 0xCE	; 206
 ad6:	96 e0       	ldi	r25, 0x06	; 6
 ad8:	0e 94 46 04 	call	0x88c	; 0x88c <xTaskGenericCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 adc:	81 30       	cpi	r24, 0x01	; 1
 ade:	81 f4       	brne	.+32     	; 0xb00 <vTaskStartScheduler+0x54>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
 ae0:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
 ae2:	8f ef       	ldi	r24, 0xFF	; 255
 ae4:	9f ef       	ldi	r25, 0xFF	; 255
 ae6:	90 93 b6 02 	sts	0x02B6, r25
 aea:	80 93 b5 02 	sts	0x02B5, r24
		xSchedulerRunning = pdTRUE;
 aee:	81 e0       	ldi	r24, 0x01	; 1
 af0:	80 93 ba 02 	sts	0x02BA, r24
		xTickCount = ( TickType_t ) 0U;
 af4:	10 92 bd 02 	sts	0x02BD, r1
 af8:	10 92 bc 02 	sts	0x02BC, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 afc:	0e 94 03 03 	call	0x606	; 0x606 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
 b00:	0f 91       	pop	r16
 b02:	ff 90       	pop	r15
 b04:	ef 90       	pop	r14
 b06:	df 90       	pop	r13
 b08:	cf 90       	pop	r12
 b0a:	bf 90       	pop	r11
 b0c:	af 90       	pop	r10
 b0e:	08 95       	ret

00000b10 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 b10:	80 91 b4 02 	lds	r24, 0x02B4
 b14:	8f 5f       	subi	r24, 0xFF	; 255
 b16:	80 93 b4 02 	sts	0x02B4, r24
 b1a:	08 95       	ret

00000b1c <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 b1c:	cf 92       	push	r12
 b1e:	df 92       	push	r13
 b20:	ef 92       	push	r14
 b22:	ff 92       	push	r15
 b24:	0f 93       	push	r16
 b26:	1f 93       	push	r17
 b28:	cf 93       	push	r28
 b2a:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 b2c:	80 91 b4 02 	lds	r24, 0x02B4
 b30:	81 11       	cpse	r24, r1
 b32:	9a c0       	rjmp	.+308    	; 0xc68 <xTaskIncrementTick+0x14c>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
 b34:	80 91 bc 02 	lds	r24, 0x02BC
 b38:	90 91 bd 02 	lds	r25, 0x02BD
 b3c:	01 96       	adiw	r24, 0x01	; 1
 b3e:	90 93 bd 02 	sts	0x02BD, r25
 b42:	80 93 bc 02 	sts	0x02BC, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
 b46:	e0 90 bc 02 	lds	r14, 0x02BC
 b4a:	f0 90 bd 02 	lds	r15, 0x02BD

			if( xConstTickCount == ( TickType_t ) 0U )
 b4e:	e1 14       	cp	r14, r1
 b50:	f1 04       	cpc	r15, r1
 b52:	b9 f4       	brne	.+46     	; 0xb82 <xTaskIncrementTick+0x66>
			{
				taskSWITCH_DELAYED_LISTS();
 b54:	80 91 c2 02 	lds	r24, 0x02C2
 b58:	90 91 c3 02 	lds	r25, 0x02C3
 b5c:	20 91 c0 02 	lds	r18, 0x02C0
 b60:	30 91 c1 02 	lds	r19, 0x02C1
 b64:	30 93 c3 02 	sts	0x02C3, r19
 b68:	20 93 c2 02 	sts	0x02C2, r18
 b6c:	90 93 c1 02 	sts	0x02C1, r25
 b70:	80 93 c0 02 	sts	0x02C0, r24
 b74:	80 91 b7 02 	lds	r24, 0x02B7
 b78:	8f 5f       	subi	r24, 0xFF	; 255
 b7a:	80 93 b7 02 	sts	0x02B7, r24
 b7e:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
 b82:	80 91 b5 02 	lds	r24, 0x02B5
 b86:	90 91 b6 02 	lds	r25, 0x02B6
 b8a:	e8 16       	cp	r14, r24
 b8c:	f9 06       	cpc	r15, r25
 b8e:	20 f4       	brcc	.+8      	; 0xb98 <xTaskIncrementTick+0x7c>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 b90:	d1 2c       	mov	r13, r1
 b92:	54 c0       	rjmp	.+168    	; 0xc3c <xTaskIncrementTick+0x120>
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
							{
								xSwitchRequired = pdTRUE;
 b94:	dc 2c       	mov	r13, r12
 b96:	03 c0       	rjmp	.+6      	; 0xb9e <xTaskIncrementTick+0x82>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
 b98:	d1 2c       	mov	r13, r1
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
							{
								xSwitchRequired = pdTRUE;
 b9a:	cc 24       	eor	r12, r12
 b9c:	c3 94       	inc	r12
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 b9e:	e0 91 c2 02 	lds	r30, 0x02C2
 ba2:	f0 91 c3 02 	lds	r31, 0x02C3
 ba6:	80 81       	ld	r24, Z
 ba8:	81 11       	cpse	r24, r1
 baa:	07 c0       	rjmp	.+14     	; 0xbba <xTaskIncrementTick+0x9e>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
 bac:	8f ef       	ldi	r24, 0xFF	; 255
 bae:	9f ef       	ldi	r25, 0xFF	; 255
 bb0:	90 93 b6 02 	sts	0x02B6, r25
 bb4:	80 93 b5 02 	sts	0x02B5, r24
						break;
 bb8:	41 c0       	rjmp	.+130    	; 0xc3c <xTaskIncrementTick+0x120>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 bba:	e0 91 c2 02 	lds	r30, 0x02C2
 bbe:	f0 91 c3 02 	lds	r31, 0x02C3
 bc2:	05 80       	ldd	r0, Z+5	; 0x05
 bc4:	f6 81       	ldd	r31, Z+6	; 0x06
 bc6:	e0 2d       	mov	r30, r0
 bc8:	c6 81       	ldd	r28, Z+6	; 0x06
 bca:	d7 81       	ldd	r29, Z+7	; 0x07
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 bcc:	2a 81       	ldd	r18, Y+2	; 0x02
 bce:	3b 81       	ldd	r19, Y+3	; 0x03

						if( xConstTickCount < xItemValue )
 bd0:	e2 16       	cp	r14, r18
 bd2:	f3 06       	cpc	r15, r19
 bd4:	28 f4       	brcc	.+10     	; 0xbe0 <xTaskIncrementTick+0xc4>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
 bd6:	30 93 b6 02 	sts	0x02B6, r19
 bda:	20 93 b5 02 	sts	0x02B5, r18
							break;
 bde:	2e c0       	rjmp	.+92     	; 0xc3c <xTaskIncrementTick+0x120>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 be0:	8e 01       	movw	r16, r28
 be2:	0e 5f       	subi	r16, 0xFE	; 254
 be4:	1f 4f       	sbci	r17, 0xFF	; 255
 be6:	c8 01       	movw	r24, r16
 be8:	0e 94 49 02 	call	0x492	; 0x492 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 bec:	8c 89       	ldd	r24, Y+20	; 0x14
 bee:	9d 89       	ldd	r25, Y+21	; 0x15
 bf0:	89 2b       	or	r24, r25
 bf2:	21 f0       	breq	.+8      	; 0xbfc <xTaskIncrementTick+0xe0>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 bf4:	ce 01       	movw	r24, r28
 bf6:	0c 96       	adiw	r24, 0x0c	; 12
 bf8:	0e 94 49 02 	call	0x492	; 0x492 <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
 bfc:	2e 89       	ldd	r18, Y+22	; 0x16
 bfe:	80 91 bb 02 	lds	r24, 0x02BB
 c02:	82 17       	cp	r24, r18
 c04:	10 f4       	brcc	.+4      	; 0xc0a <xTaskIncrementTick+0xee>
 c06:	20 93 bb 02 	sts	0x02BB, r18
 c0a:	30 e0       	ldi	r19, 0x00	; 0
 c0c:	c9 01       	movw	r24, r18
 c0e:	88 0f       	add	r24, r24
 c10:	99 1f       	adc	r25, r25
 c12:	88 0f       	add	r24, r24
 c14:	99 1f       	adc	r25, r25
 c16:	88 0f       	add	r24, r24
 c18:	99 1f       	adc	r25, r25
 c1a:	82 0f       	add	r24, r18
 c1c:	93 1f       	adc	r25, r19
 c1e:	b8 01       	movw	r22, r16
 c20:	89 53       	subi	r24, 0x39	; 57
 c22:	9d 4f       	sbci	r25, 0xFD	; 253
 c24:	0e 94 f7 01 	call	0x3ee	; 0x3ee <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 c28:	e0 91 c4 02 	lds	r30, 0x02C4
 c2c:	f0 91 c5 02 	lds	r31, 0x02C5
 c30:	9e 89       	ldd	r25, Y+22	; 0x16
 c32:	86 89       	ldd	r24, Z+22	; 0x16
 c34:	98 17       	cp	r25, r24
 c36:	08 f0       	brcs	.+2      	; 0xc3a <xTaskIncrementTick+0x11e>
 c38:	ad cf       	rjmp	.-166    	; 0xb94 <xTaskIncrementTick+0x78>
 c3a:	b1 cf       	rjmp	.-158    	; 0xb9e <xTaskIncrementTick+0x82>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 c3c:	e0 91 c4 02 	lds	r30, 0x02C4
 c40:	f0 91 c5 02 	lds	r31, 0x02C5
 c44:	86 89       	ldd	r24, Z+22	; 0x16
 c46:	90 e0       	ldi	r25, 0x00	; 0
 c48:	fc 01       	movw	r30, r24
 c4a:	ee 0f       	add	r30, r30
 c4c:	ff 1f       	adc	r31, r31
 c4e:	ee 0f       	add	r30, r30
 c50:	ff 1f       	adc	r31, r31
 c52:	ee 0f       	add	r30, r30
 c54:	ff 1f       	adc	r31, r31
 c56:	8e 0f       	add	r24, r30
 c58:	9f 1f       	adc	r25, r31
 c5a:	fc 01       	movw	r30, r24
 c5c:	e9 53       	subi	r30, 0x39	; 57
 c5e:	fd 4f       	sbci	r31, 0xFD	; 253
 c60:	80 81       	ld	r24, Z
 c62:	82 30       	cpi	r24, 0x02	; 2
 c64:	40 f4       	brcc	.+16     	; 0xc76 <xTaskIncrementTick+0x15a>
 c66:	09 c0       	rjmp	.+18     	; 0xc7a <xTaskIncrementTick+0x15e>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
 c68:	80 91 b9 02 	lds	r24, 0x02B9
 c6c:	8f 5f       	subi	r24, 0xFF	; 255
 c6e:	80 93 b9 02 	sts	0x02B9, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 c72:	d1 2c       	mov	r13, r1
 c74:	02 c0       	rjmp	.+4      	; 0xc7a <xTaskIncrementTick+0x15e>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
 c76:	dd 24       	eor	r13, r13
 c78:	d3 94       	inc	r13
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
 c7a:	80 91 b8 02 	lds	r24, 0x02B8
 c7e:	88 23       	and	r24, r24
 c80:	11 f0       	breq	.+4      	; 0xc86 <xTaskIncrementTick+0x16a>
		{
			xSwitchRequired = pdTRUE;
 c82:	dd 24       	eor	r13, r13
 c84:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
 c86:	8d 2d       	mov	r24, r13
 c88:	df 91       	pop	r29
 c8a:	cf 91       	pop	r28
 c8c:	1f 91       	pop	r17
 c8e:	0f 91       	pop	r16
 c90:	ff 90       	pop	r15
 c92:	ef 90       	pop	r14
 c94:	df 90       	pop	r13
 c96:	cf 90       	pop	r12
 c98:	08 95       	ret

00000c9a <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 c9a:	df 92       	push	r13
 c9c:	ef 92       	push	r14
 c9e:	ff 92       	push	r15
 ca0:	0f 93       	push	r16
 ca2:	1f 93       	push	r17
 ca4:	cf 93       	push	r28
 ca6:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 ca8:	0f b6       	in	r0, 0x3f	; 63
 caa:	f8 94       	cli
 cac:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
 cae:	80 91 b4 02 	lds	r24, 0x02B4
 cb2:	81 50       	subi	r24, 0x01	; 1
 cb4:	80 93 b4 02 	sts	0x02B4, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 cb8:	80 91 b4 02 	lds	r24, 0x02B4
 cbc:	81 11       	cpse	r24, r1
 cbe:	61 c0       	rjmp	.+194    	; 0xd82 <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 cc0:	80 91 be 02 	lds	r24, 0x02BE
 cc4:	81 11       	cpse	r24, r1
 cc6:	32 c0       	rjmp	.+100    	; 0xd2c <xTaskResumeAll+0x92>
 cc8:	5f c0       	rjmp	.+190    	; 0xd88 <xTaskResumeAll+0xee>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 cca:	e0 91 02 03 	lds	r30, 0x0302
 cce:	f0 91 03 03 	lds	r31, 0x0303
 cd2:	c6 81       	ldd	r28, Z+6	; 0x06
 cd4:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 cd6:	ce 01       	movw	r24, r28
 cd8:	0c 96       	adiw	r24, 0x0c	; 12
 cda:	0e 94 49 02 	call	0x492	; 0x492 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 cde:	8e 01       	movw	r16, r28
 ce0:	0e 5f       	subi	r16, 0xFE	; 254
 ce2:	1f 4f       	sbci	r17, 0xFF	; 255
 ce4:	c8 01       	movw	r24, r16
 ce6:	0e 94 49 02 	call	0x492	; 0x492 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 cea:	8e 89       	ldd	r24, Y+22	; 0x16
 cec:	90 91 bb 02 	lds	r25, 0x02BB
 cf0:	98 17       	cp	r25, r24
 cf2:	10 f4       	brcc	.+4      	; 0xcf8 <xTaskResumeAll+0x5e>
 cf4:	80 93 bb 02 	sts	0x02BB, r24
 cf8:	90 e0       	ldi	r25, 0x00	; 0
 cfa:	9c 01       	movw	r18, r24
 cfc:	22 0f       	add	r18, r18
 cfe:	33 1f       	adc	r19, r19
 d00:	22 0f       	add	r18, r18
 d02:	33 1f       	adc	r19, r19
 d04:	22 0f       	add	r18, r18
 d06:	33 1f       	adc	r19, r19
 d08:	82 0f       	add	r24, r18
 d0a:	93 1f       	adc	r25, r19
 d0c:	b8 01       	movw	r22, r16
 d0e:	89 53       	subi	r24, 0x39	; 57
 d10:	9d 4f       	sbci	r25, 0xFD	; 253
 d12:	0e 94 f7 01 	call	0x3ee	; 0x3ee <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 d16:	e0 91 c4 02 	lds	r30, 0x02C4
 d1a:	f0 91 c5 02 	lds	r31, 0x02C5
 d1e:	9e 89       	ldd	r25, Y+22	; 0x16
 d20:	86 89       	ldd	r24, Z+22	; 0x16
 d22:	98 17       	cp	r25, r24
 d24:	58 f0       	brcs	.+22     	; 0xd3c <xTaskResumeAll+0xa2>
					{
						xYieldPending = pdTRUE;
 d26:	d0 92 b8 02 	sts	0x02B8, r13
 d2a:	08 c0       	rjmp	.+16     	; 0xd3c <xTaskResumeAll+0xa2>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 d2c:	0f 2e       	mov	r0, r31
 d2e:	fd ef       	ldi	r31, 0xFD	; 253
 d30:	ef 2e       	mov	r14, r31
 d32:	f2 e0       	ldi	r31, 0x02	; 2
 d34:	ff 2e       	mov	r15, r31
 d36:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
 d38:	dd 24       	eor	r13, r13
 d3a:	d3 94       	inc	r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 d3c:	f7 01       	movw	r30, r14
 d3e:	80 81       	ld	r24, Z
 d40:	81 11       	cpse	r24, r1
 d42:	c3 cf       	rjmp	.-122    	; 0xcca <xTaskResumeAll+0x30>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
 d44:	80 91 b9 02 	lds	r24, 0x02B9
 d48:	88 23       	and	r24, r24
 d4a:	99 f0       	breq	.+38     	; 0xd72 <xTaskResumeAll+0xd8>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
 d4c:	80 91 b9 02 	lds	r24, 0x02B9
 d50:	88 23       	and	r24, r24
 d52:	79 f0       	breq	.+30     	; 0xd72 <xTaskResumeAll+0xd8>
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
 d54:	c1 e0       	ldi	r28, 0x01	; 1
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
 d56:	0e 94 8e 05 	call	0xb1c	; 0xb1c <xTaskIncrementTick>
 d5a:	81 11       	cpse	r24, r1
						{
							xYieldPending = pdTRUE;
 d5c:	c0 93 b8 02 	sts	0x02B8, r28
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
 d60:	80 91 b9 02 	lds	r24, 0x02B9
 d64:	81 50       	subi	r24, 0x01	; 1
 d66:	80 93 b9 02 	sts	0x02B9, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
 d6a:	80 91 b9 02 	lds	r24, 0x02B9
 d6e:	81 11       	cpse	r24, r1
 d70:	f2 cf       	rjmp	.-28     	; 0xd56 <xTaskResumeAll+0xbc>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
 d72:	80 91 b8 02 	lds	r24, 0x02B8
 d76:	81 30       	cpi	r24, 0x01	; 1
 d78:	31 f4       	brne	.+12     	; 0xd86 <xTaskResumeAll+0xec>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
 d7a:	0e 94 38 03 	call	0x670	; 0x670 <vPortYield>

				if( xYieldPending == pdTRUE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
 d7e:	81 e0       	ldi	r24, 0x01	; 1
 d80:	03 c0       	rjmp	.+6      	; 0xd88 <xTaskResumeAll+0xee>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
 d82:	80 e0       	ldi	r24, 0x00	; 0
 d84:	01 c0       	rjmp	.+2      	; 0xd88 <xTaskResumeAll+0xee>
 d86:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 d88:	0f 90       	pop	r0
 d8a:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
 d8c:	df 91       	pop	r29
 d8e:	cf 91       	pop	r28
 d90:	1f 91       	pop	r17
 d92:	0f 91       	pop	r16
 d94:	ff 90       	pop	r15
 d96:	ef 90       	pop	r14
 d98:	df 90       	pop	r13
 d9a:	08 95       	ret

00000d9c <prvIdleTask>:
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 d9c:	c6 e0       	ldi	r28, 0x06	; 6
 d9e:	d3 e0       	ldi	r29, 0x03	; 3

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 da0:	0f 2e       	mov	r0, r31
 da2:	f7 ec       	ldi	r31, 0xC7	; 199
 da4:	ef 2e       	mov	r14, r31
 da6:	f2 e0       	ldi	r31, 0x02	; 2
 da8:	ff 2e       	mov	r15, r31
 daa:	f0 2d       	mov	r31, r0
 dac:	28 c0       	rjmp	.+80     	; 0xdfe <prvIdleTask+0x62>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
 dae:	0e 94 88 05 	call	0xb10	; 0xb10 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 db2:	18 81       	ld	r17, Y
			}
			( void ) xTaskResumeAll();
 db4:	0e 94 4d 06 	call	0xc9a	; 0xc9a <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 db8:	11 23       	and	r17, r17
 dba:	09 f1       	breq	.+66     	; 0xdfe <prvIdleTask+0x62>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
 dbc:	0f b6       	in	r0, 0x3f	; 63
 dbe:	f8 94       	cli
 dc0:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 dc2:	e0 91 0b 03 	lds	r30, 0x030B
 dc6:	f0 91 0c 03 	lds	r31, 0x030C
 dca:	06 81       	ldd	r16, Z+6	; 0x06
 dcc:	17 81       	ldd	r17, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 dce:	c8 01       	movw	r24, r16
 dd0:	02 96       	adiw	r24, 0x02	; 2
 dd2:	0e 94 49 02 	call	0x492	; 0x492 <uxListRemove>
					--uxCurrentNumberOfTasks;
 dd6:	80 91 be 02 	lds	r24, 0x02BE
 dda:	81 50       	subi	r24, 0x01	; 1
 ddc:	80 93 be 02 	sts	0x02BE, r24
					--uxTasksDeleted;
 de0:	80 91 bf 02 	lds	r24, 0x02BF
 de4:	81 50       	subi	r24, 0x01	; 1
 de6:	80 93 bf 02 	sts	0x02BF, r24
				}
				taskEXIT_CRITICAL();
 dea:	0f 90       	pop	r0
 dec:	0f be       	out	0x3f, r0	; 63
				vPortFreeAligned( pxTCB->pxStack );
			}
		}
		#else
		{
			vPortFreeAligned( pxTCB->pxStack );
 dee:	f8 01       	movw	r30, r16
 df0:	87 89       	ldd	r24, Z+23	; 0x17
 df2:	90 8d       	ldd	r25, Z+24	; 0x18
 df4:	0e 94 b1 01 	call	0x362	; 0x362 <vPortFree>
		}
		#endif

		vPortFree( pxTCB );
 df8:	c8 01       	movw	r24, r16
 dfa:	0e 94 b1 01 	call	0x362	; 0x362 <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
 dfe:	80 91 bf 02 	lds	r24, 0x02BF
 e02:	81 11       	cpse	r24, r1
 e04:	d4 cf       	rjmp	.-88     	; 0xdae <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 e06:	f7 01       	movw	r30, r14
 e08:	80 81       	ld	r24, Z
 e0a:	82 30       	cpi	r24, 0x02	; 2
 e0c:	c0 f3       	brcs	.-16     	; 0xdfe <prvIdleTask+0x62>
			{
				taskYIELD();
 e0e:	0e 94 38 03 	call	0x670	; 0x670 <vPortYield>
 e12:	f5 cf       	rjmp	.-22     	; 0xdfe <prvIdleTask+0x62>

00000e14 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 e14:	cf 93       	push	r28
 e16:	df 93       	push	r29
 e18:	ec 01       	movw	r28, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 e1a:	00 97       	sbiw	r24, 0x00	; 0
 e1c:	b1 f0       	breq	.+44     	; 0xe4a <vTaskDelay+0x36>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
 e1e:	0e 94 88 05 	call	0xb10	; 0xb10 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 e22:	80 91 bc 02 	lds	r24, 0x02BC
 e26:	90 91 bd 02 	lds	r25, 0x02BD
 e2a:	c8 0f       	add	r28, r24
 e2c:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 e2e:	80 91 c4 02 	lds	r24, 0x02C4
 e32:	90 91 c5 02 	lds	r25, 0x02C5
 e36:	02 96       	adiw	r24, 0x02	; 2
 e38:	0e 94 49 02 	call	0x492	; 0x492 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
 e3c:	ce 01       	movw	r24, r28
 e3e:	0e 94 0f 04 	call	0x81e	; 0x81e <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 e42:	0e 94 4d 06 	call	0xc9a	; 0xc9a <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 e46:	81 11       	cpse	r24, r1
 e48:	02 c0       	rjmp	.+4      	; 0xe4e <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
 e4a:	0e 94 38 03 	call	0x670	; 0x670 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 e4e:	df 91       	pop	r29
 e50:	cf 91       	pop	r28
 e52:	08 95       	ret

00000e54 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 e54:	80 91 b4 02 	lds	r24, 0x02B4
 e58:	88 23       	and	r24, r24
 e5a:	21 f0       	breq	.+8      	; 0xe64 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 e5c:	81 e0       	ldi	r24, 0x01	; 1
 e5e:	80 93 b8 02 	sts	0x02B8, r24
 e62:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
 e64:	10 92 b8 02 	sts	0x02B8, r1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 e68:	80 91 bb 02 	lds	r24, 0x02BB
 e6c:	90 e0       	ldi	r25, 0x00	; 0
 e6e:	fc 01       	movw	r30, r24
 e70:	ee 0f       	add	r30, r30
 e72:	ff 1f       	adc	r31, r31
 e74:	ee 0f       	add	r30, r30
 e76:	ff 1f       	adc	r31, r31
 e78:	ee 0f       	add	r30, r30
 e7a:	ff 1f       	adc	r31, r31
 e7c:	8e 0f       	add	r24, r30
 e7e:	9f 1f       	adc	r25, r31
 e80:	fc 01       	movw	r30, r24
 e82:	e9 53       	subi	r30, 0x39	; 57
 e84:	fd 4f       	sbci	r31, 0xFD	; 253
 e86:	80 81       	ld	r24, Z
 e88:	81 11       	cpse	r24, r1
 e8a:	17 c0       	rjmp	.+46     	; 0xeba <vTaskSwitchContext+0x66>
 e8c:	80 91 bb 02 	lds	r24, 0x02BB
 e90:	81 50       	subi	r24, 0x01	; 1
 e92:	80 93 bb 02 	sts	0x02BB, r24
 e96:	80 91 bb 02 	lds	r24, 0x02BB
 e9a:	90 e0       	ldi	r25, 0x00	; 0
 e9c:	fc 01       	movw	r30, r24
 e9e:	ee 0f       	add	r30, r30
 ea0:	ff 1f       	adc	r31, r31
 ea2:	ee 0f       	add	r30, r30
 ea4:	ff 1f       	adc	r31, r31
 ea6:	ee 0f       	add	r30, r30
 ea8:	ff 1f       	adc	r31, r31
 eaa:	8e 0f       	add	r24, r30
 eac:	9f 1f       	adc	r25, r31
 eae:	fc 01       	movw	r30, r24
 eb0:	e9 53       	subi	r30, 0x39	; 57
 eb2:	fd 4f       	sbci	r31, 0xFD	; 253
 eb4:	80 81       	ld	r24, Z
 eb6:	88 23       	and	r24, r24
 eb8:	49 f3       	breq	.-46     	; 0xe8c <vTaskSwitchContext+0x38>
 eba:	e0 91 bb 02 	lds	r30, 0x02BB
 ebe:	f0 e0       	ldi	r31, 0x00	; 0
 ec0:	cf 01       	movw	r24, r30
 ec2:	88 0f       	add	r24, r24
 ec4:	99 1f       	adc	r25, r25
 ec6:	88 0f       	add	r24, r24
 ec8:	99 1f       	adc	r25, r25
 eca:	88 0f       	add	r24, r24
 ecc:	99 1f       	adc	r25, r25
 ece:	e8 0f       	add	r30, r24
 ed0:	f9 1f       	adc	r31, r25
 ed2:	e9 53       	subi	r30, 0x39	; 57
 ed4:	fd 4f       	sbci	r31, 0xFD	; 253
 ed6:	a1 81       	ldd	r26, Z+1	; 0x01
 ed8:	b2 81       	ldd	r27, Z+2	; 0x02
 eda:	12 96       	adiw	r26, 0x02	; 2
 edc:	0d 90       	ld	r0, X+
 ede:	bc 91       	ld	r27, X
 ee0:	a0 2d       	mov	r26, r0
 ee2:	b2 83       	std	Z+2, r27	; 0x02
 ee4:	a1 83       	std	Z+1, r26	; 0x01
 ee6:	cf 01       	movw	r24, r30
 ee8:	03 96       	adiw	r24, 0x03	; 3
 eea:	a8 17       	cp	r26, r24
 eec:	b9 07       	cpc	r27, r25
 eee:	31 f4       	brne	.+12     	; 0xefc <vTaskSwitchContext+0xa8>
 ef0:	12 96       	adiw	r26, 0x02	; 2
 ef2:	8d 91       	ld	r24, X+
 ef4:	9c 91       	ld	r25, X
 ef6:	13 97       	sbiw	r26, 0x03	; 3
 ef8:	92 83       	std	Z+2, r25	; 0x02
 efa:	81 83       	std	Z+1, r24	; 0x01
 efc:	01 80       	ldd	r0, Z+1	; 0x01
 efe:	f2 81       	ldd	r31, Z+2	; 0x02
 f00:	e0 2d       	mov	r30, r0
 f02:	86 81       	ldd	r24, Z+6	; 0x06
 f04:	97 81       	ldd	r25, Z+7	; 0x07
 f06:	90 93 c5 02 	sts	0x02C5, r25
 f0a:	80 93 c4 02 	sts	0x02C4, r24
 f0e:	08 95       	ret

00000f10 <_exit>:
 f10:	f8 94       	cli

00000f12 <__stop_program>:
 f12:	ff cf       	rjmp	.-2      	; 0xf12 <__stop_program>
