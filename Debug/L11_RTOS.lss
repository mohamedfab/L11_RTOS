
L11_RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000e04  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000054  00800060  00000e04  00000e98  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000025b  008000b4  008000b4  00000eec  2**0
                  ALLOC
  3 .stab         00000750  00000000  00000000  00000eec  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000010b  00000000  00000000  0000163c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      0000002f  00000000  00000000  00001747  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00000350  00000000  00000000  00001776  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000391f  00000000  00000000  00001ac6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000df8  00000000  00000000  000053e5  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000013f9  00000000  00000000  000061dd  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000008e4  00000000  00000000  000075d8  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000128e  00000000  00000000  00007ebc  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00003bb2  00000000  00000000  0000914a  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000360  00000000  00000000  0000ccfc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:

#include "Dio_Interface.h"

void Dio_ConfigChannel(Dio_Port port,Dio_Channel channel, Dio_Direction direction)
{
	switch (port)
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
	{
	case DIO_PORTA:
		if (direction == INPUT)
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
		{
			CLEAR_BIT(DIO_DDRA_REG,channel);
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 bc 03 	jmp	0x778	; 0x778 <__vector_7>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
		}
		else
		{
			SET_BIT(DIO_DDRA_REG,channel);
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
		}
		break;
	case DIO_PORTB:
		if (direction == INPUT)
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
		{
			CLEAR_BIT(DIO_DDRB_REG,channel);
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e4 e0       	ldi	r30, 0x04	; 4
  68:	fe e0       	ldi	r31, 0x0E	; 14
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
		}
		else
		{
			SET_BIT(DIO_DDRB_REG,channel);
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a4 3b       	cpi	r26, 0xB4	; 180
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	23 e0       	ldi	r18, 0x03	; 3
  78:	a4 eb       	ldi	r26, 0xB4	; 180
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	af 30       	cpi	r26, 0x0F	; 15
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
		}
		break;
	case DIO_PORTC:
		if (direction == INPUT)
  86:	0e 94 57 00 	call	0xae	; 0xae <main>
		{
			CLEAR_BIT(DIO_DDRC_REG,channel);
  8a:	0c 94 00 07 	jmp	0xe00	; 0xe00 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <Task_1>:
  92:	ec 01       	movw	r28, r24
  94:	ce 01       	movw	r24, r28
  96:	0e 94 93 00 	call	0x126	; 0x126 <UART_TransmitStr>
  9a:	2f ef       	ldi	r18, 0xFF	; 255
  9c:	89 e6       	ldi	r24, 0x69	; 105
  9e:	98 e1       	ldi	r25, 0x18	; 24
  a0:	21 50       	subi	r18, 0x01	; 1
  a2:	80 40       	sbci	r24, 0x00	; 0
  a4:	90 40       	sbci	r25, 0x00	; 0
		}
		else
		{
			SET_BIT(DIO_DDRC_REG,channel);
  a6:	e1 f7       	brne	.-8      	; 0xa0 <Task_1+0xe>
  a8:	00 c0       	rjmp	.+0      	; 0xaa <Task_1+0x18>
  aa:	00 00       	nop
  ac:	f3 cf       	rjmp	.-26     	; 0x94 <Task_1+0x2>

000000ae <main>:
  ae:	87 e6       	ldi	r24, 0x67	; 103
  b0:	90 e0       	ldi	r25, 0x00	; 0
  b2:	0e 94 87 00 	call	0x10e	; 0x10e <UART_Init>
  b6:	80 e6       	ldi	r24, 0x60	; 96
  b8:	90 e0       	ldi	r25, 0x00	; 0
  ba:	0e 94 93 00 	call	0x126	; 0x126 <UART_TransmitStr>
  be:	2f ef       	ldi	r18, 0xFF	; 255
		}
		break;
	case DIO_PORTD:
		if (direction == INPUT)
  c0:	87 ea       	ldi	r24, 0xA7	; 167
  c2:	91 e6       	ldi	r25, 0x61	; 97
		{
			CLEAR_BIT(DIO_DDRD_REG,channel);
  c4:	21 50       	subi	r18, 0x01	; 1
  c6:	80 40       	sbci	r24, 0x00	; 0
  c8:	90 40       	sbci	r25, 0x00	; 0
  ca:	e1 f7       	brne	.-8      	; 0xc4 <main+0x16>
  cc:	00 c0       	rjmp	.+0      	; 0xce <main+0x20>
  ce:	00 00       	nop
  d0:	a1 2c       	mov	r10, r1
  d2:	b1 2c       	mov	r11, r1
  d4:	c1 2c       	mov	r12, r1
  d6:	d1 2c       	mov	r13, r1
  d8:	e1 2c       	mov	r14, r1
  da:	f1 2c       	mov	r15, r1
  dc:	01 e0       	ldi	r16, 0x01	; 1
  de:	2f e6       	ldi	r18, 0x6F	; 111
		}
		else
		{
			SET_BIT(DIO_DDRD_REG,channel);
  e0:	30 e0       	ldi	r19, 0x00	; 0
  e2:	44 e6       	ldi	r20, 0x64	; 100
  e4:	50 e0       	ldi	r21, 0x00	; 0
  e6:	69 e8       	ldi	r22, 0x89	; 137
  e8:	70 e0       	ldi	r23, 0x00	; 0
  ea:	89 e4       	ldi	r24, 0x49	; 73
  ec:	90 e0       	ldi	r25, 0x00	; 0
  ee:	0e 94 de 03 	call	0x7bc	; 0x7bc <xTaskGenericCreate>
  f2:	02 e0       	ldi	r16, 0x02	; 2
  f4:	2f e8       	ldi	r18, 0x8F	; 143
  f6:	30 e0       	ldi	r19, 0x00	; 0
  f8:	44 e6       	ldi	r20, 0x64	; 100
	_delay_ms(2000);
	
	/*	Create Task 1	*/
	xTaskCreate(Task_1, "Task1",100,(u8*) pcTextForTask1,1,NULL);
	/*	Create Task 2	*/
	xTaskCreate(Task_1, "Task2",100,(u8*) pcTextForTask2,2,NULL);
  fa:	50 e0       	ldi	r21, 0x00	; 0
  fc:	69 ea       	ldi	r22, 0xA9	; 169
  fe:	70 e0       	ldi	r23, 0x00	; 0
 100:	89 e4       	ldi	r24, 0x49	; 73
 102:	90 e0       	ldi	r25, 0x00	; 0
 104:	0e 94 de 03 	call	0x7bc	; 0x7bc <xTaskGenericCreate>
	
	/*our tasks start executing. */
	vTaskStartScheduler();
 108:	0e 94 ee 04 	call	0x9dc	; 0x9dc <vTaskStartScheduler>
 10c:	ff cf       	rjmp	.-2      	; 0x10c <main+0x5e>

0000010e <UART_Init>:
#include "Uart_Interface.h"

void UART_Init(u16 baudRate)
{
	/* Set baud rate */
	UART_UBRRH_REG = (u8)(baudRate>>8);
 10e:	90 bd       	out	0x20, r25	; 32
	UART_UBRRL_REG = (u8)baudRate;
 110:	89 b9       	out	0x09, r24	; 9
	/* Enable receiver and transmitter */
	SET_BIT(UART_UCSRB_REG,RXEN_BIT_NO);  /* Enable Receiver*/
 112:	54 9a       	sbi	0x0a, 4	; 10
	SET_BIT(UART_UCSRB_REG,TXEN_BIT_NO);  /* Enable Transmitter */
 114:	53 9a       	sbi	0x0a, 3	; 10
	/* Set frame format: 8data, 1stop bit, Even Parity */
	UART_UCSRC_REG |= (1 << URSEL_BIT_NO)|UART_8_BIT_DATA | UART_EVEN_PARITY;
 116:	80 b5       	in	r24, 0x20	; 32
 118:	86 6a       	ori	r24, 0xA6	; 166
 11a:	80 bd       	out	0x20, r24	; 32
 11c:	08 95       	ret

0000011e <UART_TransmitChr>:
}

void UART_TransmitChr(u8 data)
{
	/* Wait for empty transmit buffer */
		while (!(CHECK_BIT(UART_UCSRA_REG,UDRE_BIT_NO)))
 11e:	5d 9b       	sbis	0x0b, 5	; 11
 120:	fe cf       	rjmp	.-4      	; 0x11e <UART_TransmitChr>
				;
		/* Put data into buffer, sends the data */
		UART_UDR_REG = data;
 122:	8c b9       	out	0x0c, r24	; 12
 124:	08 95       	ret

00000126 <UART_TransmitStr>:
}

void UART_TransmitStr(u8 *str)
{
 126:	cf 93       	push	r28
 128:	df 93       	push	r29
 12a:	ec 01       	movw	r28, r24
	/* Wait for empty transmit buffer */
	while (*str != '\0')
 12c:	88 81       	ld	r24, Y
 12e:	88 23       	and	r24, r24
 130:	31 f0       	breq	.+12     	; 0x13e <UART_TransmitStr+0x18>
				;
		/* Put data into buffer, sends the data */
		UART_UDR_REG = data;
}

void UART_TransmitStr(u8 *str)
 132:	21 96       	adiw	r28, 0x01	; 1
{
	/* Wait for empty transmit buffer */
	while (*str != '\0')
	{
		UART_TransmitChr(*str);
 134:	0e 94 8f 00 	call	0x11e	; 0x11e <UART_TransmitChr>
}

void UART_TransmitStr(u8 *str)
{
	/* Wait for empty transmit buffer */
	while (*str != '\0')
 138:	89 91       	ld	r24, Y+
 13a:	81 11       	cpse	r24, r1
 13c:	fb cf       	rjmp	.-10     	; 0x134 <UART_TransmitStr+0xe>
	{
		UART_TransmitChr(*str);
		str++;
	}
}
 13e:	df 91       	pop	r29
 140:	cf 91       	pop	r28
 142:	08 95       	ret

00000144 <prvInsertBlockIntoFreeList>:
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 144:	cf 93       	push	r28
 146:	df 93       	push	r29
 148:	ec 01       	movw	r28, r24
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 14a:	aa eb       	ldi	r26, 0xBA	; 186
 14c:	b0 e0       	ldi	r27, 0x00	; 0
 14e:	01 c0       	rjmp	.+2      	; 0x152 <prvInsertBlockIntoFreeList+0xe>
 150:	df 01       	movw	r26, r30
 152:	ed 91       	ld	r30, X+
 154:	fc 91       	ld	r31, X
 156:	11 97       	sbiw	r26, 0x01	; 1
 158:	ec 17       	cp	r30, r28
 15a:	fd 07       	cpc	r31, r29
 15c:	c8 f3       	brcs	.-14     	; 0x150 <prvInsertBlockIntoFreeList+0xc>
 15e:	cd 01       	movw	r24, r26
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 160:	12 96       	adiw	r26, 0x02	; 2
 162:	2d 91       	ld	r18, X+
 164:	3c 91       	ld	r19, X
 166:	13 97       	sbiw	r26, 0x03	; 3
 168:	ad 01       	movw	r20, r26
 16a:	42 0f       	add	r20, r18
 16c:	53 1f       	adc	r21, r19
 16e:	4c 17       	cp	r20, r28
 170:	5d 07       	cpc	r21, r29
 172:	51 f4       	brne	.+20     	; 0x188 <prvInsertBlockIntoFreeList+0x44>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 174:	ea 01       	movw	r28, r20
 176:	4a 81       	ldd	r20, Y+2	; 0x02
 178:	5b 81       	ldd	r21, Y+3	; 0x03
 17a:	24 0f       	add	r18, r20
 17c:	35 1f       	adc	r19, r21
 17e:	13 96       	adiw	r26, 0x03	; 3
 180:	3c 93       	st	X, r19
 182:	2e 93       	st	-X, r18
 184:	12 97       	sbiw	r26, 0x02	; 2
 186:	ed 01       	movw	r28, r26
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 188:	2a 81       	ldd	r18, Y+2	; 0x02
 18a:	3b 81       	ldd	r19, Y+3	; 0x03
 18c:	ae 01       	movw	r20, r28
 18e:	42 0f       	add	r20, r18
 190:	53 1f       	adc	r21, r19
 192:	e4 17       	cp	r30, r20
 194:	f5 07       	cpc	r31, r21
 196:	c1 f4       	brne	.+48     	; 0x1c8 <prvInsertBlockIntoFreeList+0x84>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 198:	40 91 b4 00 	lds	r20, 0x00B4
 19c:	50 91 b5 00 	lds	r21, 0x00B5
 1a0:	4e 17       	cp	r20, r30
 1a2:	5f 07       	cpc	r21, r31
 1a4:	71 f0       	breq	.+28     	; 0x1c2 <prvInsertBlockIntoFreeList+0x7e>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 1a6:	42 81       	ldd	r20, Z+2	; 0x02
 1a8:	53 81       	ldd	r21, Z+3	; 0x03
 1aa:	24 0f       	add	r18, r20
 1ac:	35 1f       	adc	r19, r21
 1ae:	3b 83       	std	Y+3, r19	; 0x03
 1b0:	2a 83       	std	Y+2, r18	; 0x02
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 1b2:	dc 01       	movw	r26, r24
 1b4:	ed 91       	ld	r30, X+
 1b6:	fc 91       	ld	r31, X
 1b8:	20 81       	ld	r18, Z
 1ba:	31 81       	ldd	r19, Z+1	; 0x01
 1bc:	39 83       	std	Y+1, r19	; 0x01
 1be:	28 83       	st	Y, r18
 1c0:	05 c0       	rjmp	.+10     	; 0x1cc <prvInsertBlockIntoFreeList+0x88>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
 1c2:	f9 83       	std	Y+1, r31	; 0x01
 1c4:	e8 83       	st	Y, r30
 1c6:	02 c0       	rjmp	.+4      	; 0x1cc <prvInsertBlockIntoFreeList+0x88>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 1c8:	f9 83       	std	Y+1, r31	; 0x01
 1ca:	e8 83       	st	Y, r30

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 1cc:	8c 17       	cp	r24, r28
 1ce:	9d 07       	cpc	r25, r29
 1d0:	19 f0       	breq	.+6      	; 0x1d8 <prvInsertBlockIntoFreeList+0x94>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 1d2:	fc 01       	movw	r30, r24
 1d4:	d1 83       	std	Z+1, r29	; 0x01
 1d6:	c0 83       	st	Z, r28
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 1d8:	df 91       	pop	r29
 1da:	cf 91       	pop	r28
 1dc:	08 95       	ret

000001de <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 1de:	cf 92       	push	r12
 1e0:	df 92       	push	r13
 1e2:	ef 92       	push	r14
 1e4:	ff 92       	push	r15
 1e6:	0f 93       	push	r16
 1e8:	1f 93       	push	r17
 1ea:	cf 93       	push	r28
 1ec:	df 93       	push	r29
 1ee:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
 1f0:	0e 94 20 05 	call	0xa40	; 0xa40 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
 1f4:	80 91 b4 00 	lds	r24, 0x00B4
 1f8:	90 91 b5 00 	lds	r25, 0x00B5
 1fc:	89 2b       	or	r24, r25
 1fe:	51 f5       	brne	.+84     	; 0x254 <pvPortMalloc+0x76>

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 200:	a0 ec       	ldi	r26, 0xC0	; 192
 202:	b0 e0       	ldi	r27, 0x00	; 0
 204:	b0 93 bb 00 	sts	0x00BB, r27
 208:	a0 93 ba 00 	sts	0x00BA, r26
	xStart.xBlockSize = ( size_t ) 0;
 20c:	10 92 bd 00 	sts	0x00BD, r1
 210:	10 92 bc 00 	sts	0x00BC, r1

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
	uxAddress -= xHeapStructSize;
 214:	e0 eb       	ldi	r30, 0xB0	; 176
 216:	f2 e0       	ldi	r31, 0x02	; 2
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
	pxEnd = ( void * ) uxAddress;
 218:	f0 93 b5 00 	sts	0x00B5, r31
 21c:	e0 93 b4 00 	sts	0x00B4, r30
	pxEnd->xBlockSize = 0;
 220:	13 82       	std	Z+3, r1	; 0x03
 222:	12 82       	std	Z+2, r1	; 0x02
	pxEnd->pxNextFreeBlock = NULL;
 224:	11 82       	std	Z+1, r1	; 0x01
 226:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 228:	80 ef       	ldi	r24, 0xF0	; 240
 22a:	91 e0       	ldi	r25, 0x01	; 1
 22c:	90 93 c3 00 	sts	0x00C3, r25
 230:	80 93 c2 00 	sts	0x00C2, r24
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 234:	ed 93       	st	X+, r30
 236:	fc 93       	st	X, r31

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 238:	90 93 bf 00 	sts	0x00BF, r25
 23c:	80 93 be 00 	sts	0x00BE, r24
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 240:	90 93 b9 00 	sts	0x00B9, r25
 244:	80 93 b8 00 	sts	0x00B8, r24

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 248:	80 e0       	ldi	r24, 0x00	; 0
 24a:	90 e8       	ldi	r25, 0x80	; 128
 24c:	90 93 b7 00 	sts	0x00B7, r25
 250:	80 93 b6 00 	sts	0x00B6, r24

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 254:	00 91 b6 00 	lds	r16, 0x00B6
 258:	10 91 b7 00 	lds	r17, 0x00B7
 25c:	ce 01       	movw	r24, r28
 25e:	80 23       	and	r24, r16
 260:	91 23       	and	r25, r17
 262:	89 2b       	or	r24, r25
 264:	09 f0       	breq	.+2      	; 0x268 <pvPortMalloc+0x8a>
 266:	62 c0       	rjmp	.+196    	; 0x32c <pvPortMalloc+0x14e>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
 268:	20 97       	sbiw	r28, 0x00	; 0
 26a:	09 f4       	brne	.+2      	; 0x26e <pvPortMalloc+0x90>
 26c:	62 c0       	rjmp	.+196    	; 0x332 <pvPortMalloc+0x154>
			{
				xWantedSize += xHeapStructSize;
 26e:	ae 01       	movw	r20, r28
 270:	4c 5f       	subi	r20, 0xFC	; 252
 272:	5f 4f       	sbci	r21, 0xFF	; 255
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 274:	09 f4       	brne	.+2      	; 0x278 <pvPortMalloc+0x9a>
 276:	60 c0       	rjmp	.+192    	; 0x338 <pvPortMalloc+0x15a>
 278:	e0 90 b8 00 	lds	r14, 0x00B8
 27c:	f0 90 b9 00 	lds	r15, 0x00B9
 280:	e4 16       	cp	r14, r20
 282:	f5 06       	cpc	r15, r21
 284:	08 f4       	brcc	.+2      	; 0x288 <pvPortMalloc+0xaa>
 286:	5b c0       	rjmp	.+182    	; 0x33e <pvPortMalloc+0x160>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
 288:	c0 91 ba 00 	lds	r28, 0x00BA
 28c:	d0 91 bb 00 	lds	r29, 0x00BB

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
 290:	ea eb       	ldi	r30, 0xBA	; 186
 292:	f0 e0       	ldi	r31, 0x00	; 0
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 294:	03 c0       	rjmp	.+6      	; 0x29c <pvPortMalloc+0xbe>
 296:	e9 2f       	mov	r30, r25
 298:	f8 2f       	mov	r31, r24
				{
					pxPreviousBlock = pxBlock;
					pxBlock = pxBlock->pxNextFreeBlock;
 29a:	e9 01       	movw	r28, r18
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 29c:	2a 81       	ldd	r18, Y+2	; 0x02
 29e:	3b 81       	ldd	r19, Y+3	; 0x03
 2a0:	24 17       	cp	r18, r20
 2a2:	35 07       	cpc	r19, r21
 2a4:	38 f4       	brcc	.+14     	; 0x2b4 <pvPortMalloc+0xd6>
 2a6:	28 81       	ld	r18, Y
 2a8:	39 81       	ldd	r19, Y+1	; 0x01
 2aa:	9c 2f       	mov	r25, r28
 2ac:	8d 2f       	mov	r24, r29
 2ae:	21 15       	cp	r18, r1
 2b0:	31 05       	cpc	r19, r1
 2b2:	89 f7       	brne	.-30     	; 0x296 <pvPortMalloc+0xb8>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
 2b4:	80 91 b4 00 	lds	r24, 0x00B4
 2b8:	90 91 b5 00 	lds	r25, 0x00B5
 2bc:	c8 17       	cp	r28, r24
 2be:	d9 07       	cpc	r29, r25
 2c0:	09 f4       	brne	.+2      	; 0x2c4 <pvPortMalloc+0xe6>
 2c2:	40 c0       	rjmp	.+128    	; 0x344 <pvPortMalloc+0x166>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 2c4:	c0 80       	ld	r12, Z
 2c6:	d1 80       	ldd	r13, Z+1	; 0x01
 2c8:	84 e0       	ldi	r24, 0x04	; 4
 2ca:	c8 0e       	add	r12, r24
 2cc:	d1 1c       	adc	r13, r1

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 2ce:	88 81       	ld	r24, Y
 2d0:	99 81       	ldd	r25, Y+1	; 0x01
 2d2:	91 83       	std	Z+1, r25	; 0x01
 2d4:	80 83       	st	Z, r24

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 2d6:	2a 81       	ldd	r18, Y+2	; 0x02
 2d8:	3b 81       	ldd	r19, Y+3	; 0x03
 2da:	24 1b       	sub	r18, r20
 2dc:	35 0b       	sbc	r19, r21
 2de:	29 30       	cpi	r18, 0x09	; 9
 2e0:	31 05       	cpc	r19, r1
 2e2:	50 f0       	brcs	.+20     	; 0x2f8 <pvPortMalloc+0x11a>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 2e4:	ce 01       	movw	r24, r28
 2e6:	84 0f       	add	r24, r20
 2e8:	95 1f       	adc	r25, r21
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 2ea:	fc 01       	movw	r30, r24
 2ec:	33 83       	std	Z+3, r19	; 0x03
 2ee:	22 83       	std	Z+2, r18	; 0x02
						pxBlock->xBlockSize = xWantedSize;
 2f0:	5b 83       	std	Y+3, r21	; 0x03
 2f2:	4a 83       	std	Y+2, r20	; 0x02

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 2f4:	0e 94 a2 00 	call	0x144	; 0x144 <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
 2f8:	8a 81       	ldd	r24, Y+2	; 0x02
 2fa:	9b 81       	ldd	r25, Y+3	; 0x03
 2fc:	e8 1a       	sub	r14, r24
 2fe:	f9 0a       	sbc	r15, r25
 300:	f0 92 b9 00 	sts	0x00B9, r15
 304:	e0 92 b8 00 	sts	0x00B8, r14

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 308:	20 91 be 00 	lds	r18, 0x00BE
 30c:	30 91 bf 00 	lds	r19, 0x00BF
 310:	e2 16       	cp	r14, r18
 312:	f3 06       	cpc	r15, r19
 314:	20 f4       	brcc	.+8      	; 0x31e <pvPortMalloc+0x140>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 316:	f0 92 bf 00 	sts	0x00BF, r15
 31a:	e0 92 be 00 	sts	0x00BE, r14
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 31e:	08 2b       	or	r16, r24
 320:	19 2b       	or	r17, r25
 322:	1b 83       	std	Y+3, r17	; 0x03
 324:	0a 83       	std	Y+2, r16	; 0x02
					pxBlock->pxNextFreeBlock = NULL;
 326:	19 82       	std	Y+1, r1	; 0x01
 328:	18 82       	st	Y, r1
 32a:	0e c0       	rjmp	.+28     	; 0x348 <pvPortMalloc+0x16a>
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
 32c:	c1 2c       	mov	r12, r1
 32e:	d1 2c       	mov	r13, r1
 330:	0b c0       	rjmp	.+22     	; 0x348 <pvPortMalloc+0x16a>
 332:	c1 2c       	mov	r12, r1
 334:	d1 2c       	mov	r13, r1
 336:	08 c0       	rjmp	.+16     	; 0x348 <pvPortMalloc+0x16a>
 338:	c1 2c       	mov	r12, r1
 33a:	d1 2c       	mov	r13, r1
 33c:	05 c0       	rjmp	.+10     	; 0x348 <pvPortMalloc+0x16a>
 33e:	c1 2c       	mov	r12, r1
 340:	d1 2c       	mov	r13, r1
 342:	02 c0       	rjmp	.+4      	; 0x348 <pvPortMalloc+0x16a>
 344:	c1 2c       	mov	r12, r1
 346:	d1 2c       	mov	r13, r1
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 348:	0e 94 e5 05 	call	0xbca	; 0xbca <xTaskResumeAll>
	}
	#endif

	configASSERT( ( ( ( uint32_t ) pvReturn ) & portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
 34c:	8c 2d       	mov	r24, r12
 34e:	9d 2d       	mov	r25, r13
 350:	df 91       	pop	r29
 352:	cf 91       	pop	r28
 354:	1f 91       	pop	r17
 356:	0f 91       	pop	r16
 358:	ff 90       	pop	r15
 35a:	ef 90       	pop	r14
 35c:	df 90       	pop	r13
 35e:	cf 90       	pop	r12
 360:	08 95       	ret

00000362 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 362:	cf 93       	push	r28
 364:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
 366:	00 97       	sbiw	r24, 0x00	; 0
 368:	69 f1       	breq	.+90     	; 0x3c4 <vPortFree+0x62>

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
		configASSERT( pxLink->pxNextFreeBlock == NULL );

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
 36a:	fc 01       	movw	r30, r24
 36c:	34 97       	sbiw	r30, 0x04	; 4
 36e:	22 81       	ldd	r18, Z+2	; 0x02
 370:	33 81       	ldd	r19, Z+3	; 0x03
 372:	40 91 b6 00 	lds	r20, 0x00B6
 376:	50 91 b7 00 	lds	r21, 0x00B7
 37a:	ba 01       	movw	r22, r20
 37c:	62 23       	and	r22, r18
 37e:	73 23       	and	r23, r19
 380:	67 2b       	or	r22, r23
 382:	01 f1       	breq	.+64     	; 0x3c4 <vPortFree+0x62>
		{
			if( pxLink->pxNextFreeBlock == NULL )
 384:	fc 01       	movw	r30, r24
 386:	34 97       	sbiw	r30, 0x04	; 4
 388:	60 81       	ld	r22, Z
 38a:	71 81       	ldd	r23, Z+1	; 0x01
 38c:	67 2b       	or	r22, r23
 38e:	d1 f4       	brne	.+52     	; 0x3c4 <vPortFree+0x62>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 390:	ef 01       	movw	r28, r30
 392:	40 95       	com	r20
 394:	50 95       	com	r21
 396:	24 23       	and	r18, r20
 398:	35 23       	and	r19, r21
 39a:	33 83       	std	Z+3, r19	; 0x03
 39c:	22 83       	std	Z+2, r18	; 0x02

				vTaskSuspendAll();
 39e:	0e 94 20 05 	call	0xa40	; 0xa40 <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
 3a2:	20 91 b8 00 	lds	r18, 0x00B8
 3a6:	30 91 b9 00 	lds	r19, 0x00B9
 3aa:	8a 81       	ldd	r24, Y+2	; 0x02
 3ac:	9b 81       	ldd	r25, Y+3	; 0x03
 3ae:	82 0f       	add	r24, r18
 3b0:	93 1f       	adc	r25, r19
 3b2:	90 93 b9 00 	sts	0x00B9, r25
 3b6:	80 93 b8 00 	sts	0x00B8, r24
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 3ba:	ce 01       	movw	r24, r28
 3bc:	0e 94 a2 00 	call	0x144	; 0x144 <prvInsertBlockIntoFreeList>
				}
				( void ) xTaskResumeAll();
 3c0:	0e 94 e5 05 	call	0xbca	; 0xbca <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
 3c4:	df 91       	pop	r29
 3c6:	cf 91       	pop	r28
 3c8:	08 95       	ret

000003ca <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 3ca:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 3cc:	03 96       	adiw	r24, 0x03	; 3
 3ce:	92 83       	std	Z+2, r25	; 0x02
 3d0:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 3d2:	2f ef       	ldi	r18, 0xFF	; 255
 3d4:	3f ef       	ldi	r19, 0xFF	; 255
 3d6:	34 83       	std	Z+4, r19	; 0x04
 3d8:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 3da:	96 83       	std	Z+6, r25	; 0x06
 3dc:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 3de:	90 87       	std	Z+8, r25	; 0x08
 3e0:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 3e2:	10 82       	st	Z, r1
 3e4:	08 95       	ret

000003e6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 3e6:	fc 01       	movw	r30, r24
 3e8:	11 86       	std	Z+9, r1	; 0x09
 3ea:	10 86       	std	Z+8, r1	; 0x08
 3ec:	08 95       	ret

000003ee <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 3ee:	cf 93       	push	r28
 3f0:	df 93       	push	r29
 3f2:	9c 01       	movw	r18, r24
 3f4:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
 3f6:	dc 01       	movw	r26, r24
 3f8:	11 96       	adiw	r26, 0x01	; 1
 3fa:	cd 91       	ld	r28, X+
 3fc:	dc 91       	ld	r29, X
 3fe:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 400:	d3 83       	std	Z+3, r29	; 0x03
 402:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 404:	8c 81       	ldd	r24, Y+4	; 0x04
 406:	9d 81       	ldd	r25, Y+5	; 0x05
 408:	95 83       	std	Z+5, r25	; 0x05
 40a:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 40c:	8c 81       	ldd	r24, Y+4	; 0x04
 40e:	9d 81       	ldd	r25, Y+5	; 0x05
 410:	dc 01       	movw	r26, r24
 412:	13 96       	adiw	r26, 0x03	; 3
 414:	7c 93       	st	X, r23
 416:	6e 93       	st	-X, r22
 418:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
 41a:	7d 83       	std	Y+5, r23	; 0x05
 41c:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 41e:	31 87       	std	Z+9, r19	; 0x09
 420:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
 422:	f9 01       	movw	r30, r18
 424:	80 81       	ld	r24, Z
 426:	8f 5f       	subi	r24, 0xFF	; 255
 428:	80 83       	st	Z, r24
}
 42a:	df 91       	pop	r29
 42c:	cf 91       	pop	r28
 42e:	08 95       	ret

00000430 <uxListRemove>:
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 430:	cf 93       	push	r28
 432:	df 93       	push	r29
 434:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 436:	a0 85       	ldd	r26, Z+8	; 0x08
 438:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 43a:	c2 81       	ldd	r28, Z+2	; 0x02
 43c:	d3 81       	ldd	r29, Z+3	; 0x03
 43e:	84 81       	ldd	r24, Z+4	; 0x04
 440:	95 81       	ldd	r25, Z+5	; 0x05
 442:	9d 83       	std	Y+5, r25	; 0x05
 444:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 446:	c4 81       	ldd	r28, Z+4	; 0x04
 448:	d5 81       	ldd	r29, Z+5	; 0x05
 44a:	82 81       	ldd	r24, Z+2	; 0x02
 44c:	93 81       	ldd	r25, Z+3	; 0x03
 44e:	9b 83       	std	Y+3, r25	; 0x03
 450:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 452:	11 96       	adiw	r26, 0x01	; 1
 454:	cd 91       	ld	r28, X+
 456:	dc 91       	ld	r29, X
 458:	12 97       	sbiw	r26, 0x02	; 2
 45a:	ce 17       	cp	r28, r30
 45c:	df 07       	cpc	r29, r31
 45e:	31 f4       	brne	.+12     	; 0x46c <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 460:	8c 81       	ldd	r24, Y+4	; 0x04
 462:	9d 81       	ldd	r25, Y+5	; 0x05
 464:	12 96       	adiw	r26, 0x02	; 2
 466:	9c 93       	st	X, r25
 468:	8e 93       	st	-X, r24
 46a:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 46c:	11 86       	std	Z+9, r1	; 0x09
 46e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 470:	8c 91       	ld	r24, X
 472:	81 50       	subi	r24, 0x01	; 1
 474:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
 476:	df 91       	pop	r29
 478:	cf 91       	pop	r28
 47a:	08 95       	ret

0000047c <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
 47c:	31 e1       	ldi	r19, 0x11	; 17
 47e:	fc 01       	movw	r30, r24
 480:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
 482:	31 97       	sbiw	r30, 0x01	; 1
 484:	22 e2       	ldi	r18, 0x22	; 34
 486:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
 488:	fc 01       	movw	r30, r24
 48a:	32 97       	sbiw	r30, 0x02	; 2
 48c:	a3 e3       	ldi	r26, 0x33	; 51
 48e:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
 490:	fc 01       	movw	r30, r24
 492:	33 97       	sbiw	r30, 0x03	; 3
 494:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
 496:	fc 01       	movw	r30, r24
 498:	34 97       	sbiw	r30, 0x04	; 4
 49a:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
 49c:	fc 01       	movw	r30, r24
 49e:	35 97       	sbiw	r30, 0x05	; 5
 4a0:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
 4a2:	fc 01       	movw	r30, r24
 4a4:	36 97       	sbiw	r30, 0x06	; 6
 4a6:	60 e8       	ldi	r22, 0x80	; 128
 4a8:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
 4aa:	fc 01       	movw	r30, r24
 4ac:	37 97       	sbiw	r30, 0x07	; 7
 4ae:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
 4b0:	fc 01       	movw	r30, r24
 4b2:	38 97       	sbiw	r30, 0x08	; 8
 4b4:	62 e0       	ldi	r22, 0x02	; 2
 4b6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
 4b8:	fc 01       	movw	r30, r24
 4ba:	39 97       	sbiw	r30, 0x09	; 9
 4bc:	63 e0       	ldi	r22, 0x03	; 3
 4be:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
 4c0:	fc 01       	movw	r30, r24
 4c2:	3a 97       	sbiw	r30, 0x0a	; 10
 4c4:	64 e0       	ldi	r22, 0x04	; 4
 4c6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
 4c8:	fc 01       	movw	r30, r24
 4ca:	3b 97       	sbiw	r30, 0x0b	; 11
 4cc:	65 e0       	ldi	r22, 0x05	; 5
 4ce:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
 4d0:	fc 01       	movw	r30, r24
 4d2:	3c 97       	sbiw	r30, 0x0c	; 12
 4d4:	66 e0       	ldi	r22, 0x06	; 6
 4d6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
 4d8:	fc 01       	movw	r30, r24
 4da:	3d 97       	sbiw	r30, 0x0d	; 13
 4dc:	67 e0       	ldi	r22, 0x07	; 7
 4de:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
 4e0:	fc 01       	movw	r30, r24
 4e2:	3e 97       	sbiw	r30, 0x0e	; 14
 4e4:	68 e0       	ldi	r22, 0x08	; 8
 4e6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
 4e8:	fc 01       	movw	r30, r24
 4ea:	3f 97       	sbiw	r30, 0x0f	; 15
 4ec:	69 e0       	ldi	r22, 0x09	; 9
 4ee:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
 4f0:	fc 01       	movw	r30, r24
 4f2:	70 97       	sbiw	r30, 0x10	; 16
 4f4:	60 e1       	ldi	r22, 0x10	; 16
 4f6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
 4f8:	fc 01       	movw	r30, r24
 4fa:	71 97       	sbiw	r30, 0x11	; 17
 4fc:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
 4fe:	fc 01       	movw	r30, r24
 500:	72 97       	sbiw	r30, 0x12	; 18
 502:	32 e1       	ldi	r19, 0x12	; 18
 504:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
 506:	fc 01       	movw	r30, r24
 508:	73 97       	sbiw	r30, 0x13	; 19
 50a:	33 e1       	ldi	r19, 0x13	; 19
 50c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
 50e:	fc 01       	movw	r30, r24
 510:	74 97       	sbiw	r30, 0x14	; 20
 512:	34 e1       	ldi	r19, 0x14	; 20
 514:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
 516:	fc 01       	movw	r30, r24
 518:	75 97       	sbiw	r30, 0x15	; 21
 51a:	35 e1       	ldi	r19, 0x15	; 21
 51c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
 51e:	fc 01       	movw	r30, r24
 520:	76 97       	sbiw	r30, 0x16	; 22
 522:	36 e1       	ldi	r19, 0x16	; 22
 524:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
 526:	fc 01       	movw	r30, r24
 528:	77 97       	sbiw	r30, 0x17	; 23
 52a:	37 e1       	ldi	r19, 0x17	; 23
 52c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
 52e:	fc 01       	movw	r30, r24
 530:	78 97       	sbiw	r30, 0x18	; 24
 532:	38 e1       	ldi	r19, 0x18	; 24
 534:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
 536:	fc 01       	movw	r30, r24
 538:	79 97       	sbiw	r30, 0x19	; 25
 53a:	39 e1       	ldi	r19, 0x19	; 25
 53c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
 53e:	fc 01       	movw	r30, r24
 540:	7a 97       	sbiw	r30, 0x1a	; 26
 542:	30 e2       	ldi	r19, 0x20	; 32
 544:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
 546:	fc 01       	movw	r30, r24
 548:	7b 97       	sbiw	r30, 0x1b	; 27
 54a:	31 e2       	ldi	r19, 0x21	; 33
 54c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
 54e:	fc 01       	movw	r30, r24
 550:	7c 97       	sbiw	r30, 0x1c	; 28
 552:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
 554:	fc 01       	movw	r30, r24
 556:	7d 97       	sbiw	r30, 0x1d	; 29
 558:	23 e2       	ldi	r18, 0x23	; 35
 55a:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
 55c:	fc 01       	movw	r30, r24
 55e:	7e 97       	sbiw	r30, 0x1e	; 30
 560:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
 562:	fc 01       	movw	r30, r24
 564:	7f 97       	sbiw	r30, 0x1f	; 31
 566:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
 568:	fc 01       	movw	r30, r24
 56a:	b0 97       	sbiw	r30, 0x20	; 32
 56c:	26 e2       	ldi	r18, 0x26	; 38
 56e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
 570:	fc 01       	movw	r30, r24
 572:	b1 97       	sbiw	r30, 0x21	; 33
 574:	27 e2       	ldi	r18, 0x27	; 39
 576:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
 578:	fc 01       	movw	r30, r24
 57a:	b2 97       	sbiw	r30, 0x22	; 34
 57c:	28 e2       	ldi	r18, 0x28	; 40
 57e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
 580:	fc 01       	movw	r30, r24
 582:	b3 97       	sbiw	r30, 0x23	; 35
 584:	29 e2       	ldi	r18, 0x29	; 41
 586:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
 588:	fc 01       	movw	r30, r24
 58a:	b4 97       	sbiw	r30, 0x24	; 36
 58c:	20 e3       	ldi	r18, 0x30	; 48
 58e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
 590:	fc 01       	movw	r30, r24
 592:	b5 97       	sbiw	r30, 0x25	; 37
 594:	21 e3       	ldi	r18, 0x31	; 49
 596:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
 598:	9c 01       	movw	r18, r24
 59a:	26 52       	subi	r18, 0x26	; 38
 59c:	31 09       	sbc	r19, r1
}
 59e:	82 2f       	mov	r24, r18
 5a0:	93 2f       	mov	r25, r19
 5a2:	08 95       	ret

000005a4 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
 5a4:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
 5a6:	89 ef       	ldi	r24, 0xF9	; 249
 5a8:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
 5aa:	8b e0       	ldi	r24, 0x0B	; 11
 5ac:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
 5ae:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
 5b0:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
 5b2:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
 5b4:	a0 91 c4 02 	lds	r26, 0x02C4
 5b8:	b0 91 c5 02 	lds	r27, 0x02C5
 5bc:	cd 91       	ld	r28, X+
 5be:	cd bf       	out	0x3d, r28	; 61
 5c0:	dd 91       	ld	r29, X+
 5c2:	de bf       	out	0x3e, r29	; 62
 5c4:	ff 91       	pop	r31
 5c6:	ef 91       	pop	r30
 5c8:	df 91       	pop	r29
 5ca:	cf 91       	pop	r28
 5cc:	bf 91       	pop	r27
 5ce:	af 91       	pop	r26
 5d0:	9f 91       	pop	r25
 5d2:	8f 91       	pop	r24
 5d4:	7f 91       	pop	r23
 5d6:	6f 91       	pop	r22
 5d8:	5f 91       	pop	r21
 5da:	4f 91       	pop	r20
 5dc:	3f 91       	pop	r19
 5de:	2f 91       	pop	r18
 5e0:	1f 91       	pop	r17
 5e2:	0f 91       	pop	r16
 5e4:	ff 90       	pop	r15
 5e6:	ef 90       	pop	r14
 5e8:	df 90       	pop	r13
 5ea:	cf 90       	pop	r12
 5ec:	bf 90       	pop	r11
 5ee:	af 90       	pop	r10
 5f0:	9f 90       	pop	r9
 5f2:	8f 90       	pop	r8
 5f4:	7f 90       	pop	r7
 5f6:	6f 90       	pop	r6
 5f8:	5f 90       	pop	r5
 5fa:	4f 90       	pop	r4
 5fc:	3f 90       	pop	r3
 5fe:	2f 90       	pop	r2
 600:	1f 90       	pop	r1
 602:	0f 90       	pop	r0
 604:	0f be       	out	0x3f, r0	; 63
 606:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
 608:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
 60a:	81 e0       	ldi	r24, 0x01	; 1
 60c:	08 95       	ret

0000060e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 60e:	0f 92       	push	r0
 610:	0f b6       	in	r0, 0x3f	; 63
 612:	f8 94       	cli
 614:	0f 92       	push	r0
 616:	1f 92       	push	r1
 618:	11 24       	eor	r1, r1
 61a:	2f 92       	push	r2
 61c:	3f 92       	push	r3
 61e:	4f 92       	push	r4
 620:	5f 92       	push	r5
 622:	6f 92       	push	r6
 624:	7f 92       	push	r7
 626:	8f 92       	push	r8
 628:	9f 92       	push	r9
 62a:	af 92       	push	r10
 62c:	bf 92       	push	r11
 62e:	cf 92       	push	r12
 630:	df 92       	push	r13
 632:	ef 92       	push	r14
 634:	ff 92       	push	r15
 636:	0f 93       	push	r16
 638:	1f 93       	push	r17
 63a:	2f 93       	push	r18
 63c:	3f 93       	push	r19
 63e:	4f 93       	push	r20
 640:	5f 93       	push	r21
 642:	6f 93       	push	r22
 644:	7f 93       	push	r23
 646:	8f 93       	push	r24
 648:	9f 93       	push	r25
 64a:	af 93       	push	r26
 64c:	bf 93       	push	r27
 64e:	cf 93       	push	r28
 650:	df 93       	push	r29
 652:	ef 93       	push	r30
 654:	ff 93       	push	r31
 656:	a0 91 c4 02 	lds	r26, 0x02C4
 65a:	b0 91 c5 02 	lds	r27, 0x02C5
 65e:	0d b6       	in	r0, 0x3d	; 61
 660:	0d 92       	st	X+, r0
 662:	0e b6       	in	r0, 0x3e	; 62
 664:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 666:	0e 94 a2 06 	call	0xd44	; 0xd44 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 66a:	a0 91 c4 02 	lds	r26, 0x02C4
 66e:	b0 91 c5 02 	lds	r27, 0x02C5
 672:	cd 91       	ld	r28, X+
 674:	cd bf       	out	0x3d, r28	; 61
 676:	dd 91       	ld	r29, X+
 678:	de bf       	out	0x3e, r29	; 62
 67a:	ff 91       	pop	r31
 67c:	ef 91       	pop	r30
 67e:	df 91       	pop	r29
 680:	cf 91       	pop	r28
 682:	bf 91       	pop	r27
 684:	af 91       	pop	r26
 686:	9f 91       	pop	r25
 688:	8f 91       	pop	r24
 68a:	7f 91       	pop	r23
 68c:	6f 91       	pop	r22
 68e:	5f 91       	pop	r21
 690:	4f 91       	pop	r20
 692:	3f 91       	pop	r19
 694:	2f 91       	pop	r18
 696:	1f 91       	pop	r17
 698:	0f 91       	pop	r16
 69a:	ff 90       	pop	r15
 69c:	ef 90       	pop	r14
 69e:	df 90       	pop	r13
 6a0:	cf 90       	pop	r12
 6a2:	bf 90       	pop	r11
 6a4:	af 90       	pop	r10
 6a6:	9f 90       	pop	r9
 6a8:	8f 90       	pop	r8
 6aa:	7f 90       	pop	r7
 6ac:	6f 90       	pop	r6
 6ae:	5f 90       	pop	r5
 6b0:	4f 90       	pop	r4
 6b2:	3f 90       	pop	r3
 6b4:	2f 90       	pop	r2
 6b6:	1f 90       	pop	r1
 6b8:	0f 90       	pop	r0
 6ba:	0f be       	out	0x3f, r0	; 63
 6bc:	0f 90       	pop	r0

	asm volatile ( "ret" );
 6be:	08 95       	ret

000006c0 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 6c0:	0f 92       	push	r0
 6c2:	0f b6       	in	r0, 0x3f	; 63
 6c4:	f8 94       	cli
 6c6:	0f 92       	push	r0
 6c8:	1f 92       	push	r1
 6ca:	11 24       	eor	r1, r1
 6cc:	2f 92       	push	r2
 6ce:	3f 92       	push	r3
 6d0:	4f 92       	push	r4
 6d2:	5f 92       	push	r5
 6d4:	6f 92       	push	r6
 6d6:	7f 92       	push	r7
 6d8:	8f 92       	push	r8
 6da:	9f 92       	push	r9
 6dc:	af 92       	push	r10
 6de:	bf 92       	push	r11
 6e0:	cf 92       	push	r12
 6e2:	df 92       	push	r13
 6e4:	ef 92       	push	r14
 6e6:	ff 92       	push	r15
 6e8:	0f 93       	push	r16
 6ea:	1f 93       	push	r17
 6ec:	2f 93       	push	r18
 6ee:	3f 93       	push	r19
 6f0:	4f 93       	push	r20
 6f2:	5f 93       	push	r21
 6f4:	6f 93       	push	r22
 6f6:	7f 93       	push	r23
 6f8:	8f 93       	push	r24
 6fa:	9f 93       	push	r25
 6fc:	af 93       	push	r26
 6fe:	bf 93       	push	r27
 700:	cf 93       	push	r28
 702:	df 93       	push	r29
 704:	ef 93       	push	r30
 706:	ff 93       	push	r31
 708:	a0 91 c4 02 	lds	r26, 0x02C4
 70c:	b0 91 c5 02 	lds	r27, 0x02C5
 710:	0d b6       	in	r0, 0x3d	; 61
 712:	0d 92       	st	X+, r0
 714:	0e b6       	in	r0, 0x3e	; 62
 716:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
 718:	0e 94 26 05 	call	0xa4c	; 0xa4c <xTaskIncrementTick>
 71c:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
 71e:	0e 94 a2 06 	call	0xd44	; 0xd44 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
 722:	a0 91 c4 02 	lds	r26, 0x02C4
 726:	b0 91 c5 02 	lds	r27, 0x02C5
 72a:	cd 91       	ld	r28, X+
 72c:	cd bf       	out	0x3d, r28	; 61
 72e:	dd 91       	ld	r29, X+
 730:	de bf       	out	0x3e, r29	; 62
 732:	ff 91       	pop	r31
 734:	ef 91       	pop	r30
 736:	df 91       	pop	r29
 738:	cf 91       	pop	r28
 73a:	bf 91       	pop	r27
 73c:	af 91       	pop	r26
 73e:	9f 91       	pop	r25
 740:	8f 91       	pop	r24
 742:	7f 91       	pop	r23
 744:	6f 91       	pop	r22
 746:	5f 91       	pop	r21
 748:	4f 91       	pop	r20
 74a:	3f 91       	pop	r19
 74c:	2f 91       	pop	r18
 74e:	1f 91       	pop	r17
 750:	0f 91       	pop	r16
 752:	ff 90       	pop	r15
 754:	ef 90       	pop	r14
 756:	df 90       	pop	r13
 758:	cf 90       	pop	r12
 75a:	bf 90       	pop	r11
 75c:	af 90       	pop	r10
 75e:	9f 90       	pop	r9
 760:	8f 90       	pop	r8
 762:	7f 90       	pop	r7
 764:	6f 90       	pop	r6
 766:	5f 90       	pop	r5
 768:	4f 90       	pop	r4
 76a:	3f 90       	pop	r3
 76c:	2f 90       	pop	r2
 76e:	1f 90       	pop	r1
 770:	0f 90       	pop	r0
 772:	0f be       	out	0x3f, r0	; 63
 774:	0f 90       	pop	r0

	asm volatile ( "ret" );
 776:	08 95       	ret

00000778 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
 778:	0e 94 60 03 	call	0x6c0	; 0x6c0 <vPortYieldFromTick>
		asm volatile ( "reti" );
 77c:	18 95       	reti

0000077e <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 77e:	e0 91 c2 02 	lds	r30, 0x02C2
 782:	f0 91 c3 02 	lds	r31, 0x02C3
 786:	80 81       	ld	r24, Z
 788:	81 11       	cpse	r24, r1
 78a:	07 c0       	rjmp	.+14     	; 0x79a <prvResetNextTaskUnblockTime+0x1c>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 78c:	8f ef       	ldi	r24, 0xFF	; 255
 78e:	9f ef       	ldi	r25, 0xFF	; 255
 790:	90 93 b6 02 	sts	0x02B6, r25
 794:	80 93 b5 02 	sts	0x02B5, r24
 798:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 79a:	e0 91 c2 02 	lds	r30, 0x02C2
 79e:	f0 91 c3 02 	lds	r31, 0x02C3
 7a2:	05 80       	ldd	r0, Z+5	; 0x05
 7a4:	f6 81       	ldd	r31, Z+6	; 0x06
 7a6:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
 7a8:	06 80       	ldd	r0, Z+6	; 0x06
 7aa:	f7 81       	ldd	r31, Z+7	; 0x07
 7ac:	e0 2d       	mov	r30, r0
 7ae:	82 81       	ldd	r24, Z+2	; 0x02
 7b0:	93 81       	ldd	r25, Z+3	; 0x03
 7b2:	90 93 b6 02 	sts	0x02B6, r25
 7b6:	80 93 b5 02 	sts	0x02B5, r24
 7ba:	08 95       	ret

000007bc <xTaskGenericCreate>:

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 7bc:	4f 92       	push	r4
 7be:	5f 92       	push	r5
 7c0:	6f 92       	push	r6
 7c2:	7f 92       	push	r7
 7c4:	8f 92       	push	r8
 7c6:	9f 92       	push	r9
 7c8:	af 92       	push	r10
 7ca:	bf 92       	push	r11
 7cc:	cf 92       	push	r12
 7ce:	df 92       	push	r13
 7d0:	ef 92       	push	r14
 7d2:	ff 92       	push	r15
 7d4:	0f 93       	push	r16
 7d6:	1f 93       	push	r17
 7d8:	cf 93       	push	r28
 7da:	df 93       	push	r29
 7dc:	4c 01       	movw	r8, r24
 7de:	5b 01       	movw	r10, r22
 7e0:	2a 01       	movw	r4, r20
 7e2:	39 01       	movw	r6, r18
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 7e4:	c1 14       	cp	r12, r1
 7e6:	d1 04       	cpc	r13, r1
 7e8:	39 f4       	brne	.+14     	; 0x7f8 <xTaskGenericCreate+0x3c>
 7ea:	ca 01       	movw	r24, r20
 7ec:	0e 94 ef 00 	call	0x1de	; 0x1de <pvPortMalloc>
 7f0:	6c 01       	movw	r12, r24

		if( pxStack != NULL )
 7f2:	00 97       	sbiw	r24, 0x00	; 0
 7f4:	09 f4       	brne	.+2      	; 0x7f8 <xTaskGenericCreate+0x3c>
 7f6:	e0 c0       	rjmp	.+448    	; 0x9b8 <__stack+0x159>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 7f8:	86 e2       	ldi	r24, 0x26	; 38
 7fa:	90 e0       	ldi	r25, 0x00	; 0
 7fc:	0e 94 ef 00 	call	0x1de	; 0x1de <pvPortMalloc>
 800:	ec 01       	movw	r28, r24

			if( pxNewTCB != NULL )
 802:	00 97       	sbiw	r24, 0x00	; 0
 804:	71 f0       	breq	.+28     	; 0x822 <xTaskGenericCreate+0x66>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
 806:	d8 8e       	std	Y+24, r13	; 0x18
 808:	cf 8a       	std	Y+23, r12	; 0x17
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
 80a:	81 e0       	ldi	r24, 0x01	; 1
 80c:	48 1a       	sub	r4, r24
 80e:	51 08       	sbc	r5, r1
 810:	c4 0c       	add	r12, r4
 812:	d5 1c       	adc	r13, r5
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
 814:	d5 01       	movw	r26, r10
 816:	8c 91       	ld	r24, X
 818:	89 8f       	std	Y+25, r24	; 0x19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 81a:	8c 91       	ld	r24, X
 81c:	81 11       	cpse	r24, r1
 81e:	05 c0       	rjmp	.+10     	; 0x82a <xTaskGenericCreate+0x6e>
 820:	15 c0       	rjmp	.+42     	; 0x84c <xTaskGenericCreate+0x90>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
 822:	c6 01       	movw	r24, r12
 824:	0e 94 b1 01 	call	0x362	; 0x362 <vPortFree>
 828:	c7 c0       	rjmp	.+398    	; 0x9b8 <__stack+0x159>
	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName );

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
 82a:	ae 01       	movw	r20, r28
 82c:	46 5e       	subi	r20, 0xE6	; 230
 82e:	5f 4f       	sbci	r21, 0xFF	; 255
 830:	f5 01       	movw	r30, r10
 832:	31 96       	adiw	r30, 0x01	; 1
 834:	27 e0       	ldi	r18, 0x07	; 7
 836:	cf 01       	movw	r24, r30
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
 838:	31 91       	ld	r19, Z+
 83a:	da 01       	movw	r26, r20
 83c:	3d 93       	st	X+, r19
 83e:	ad 01       	movw	r20, r26

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 840:	dc 01       	movw	r26, r24
 842:	8c 91       	ld	r24, X
 844:	88 23       	and	r24, r24
 846:	11 f0       	breq	.+4      	; 0x84c <xTaskGenericCreate+0x90>
 848:	21 50       	subi	r18, 0x01	; 1
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 84a:	a9 f7       	brne	.-22     	; 0x836 <xTaskGenericCreate+0x7a>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 84c:	18 a2       	std	Y+32, r1	; 0x20
 84e:	10 2f       	mov	r17, r16
 850:	04 30       	cpi	r16, 0x04	; 4
 852:	08 f0       	brcs	.+2      	; 0x856 <xTaskGenericCreate+0x9a>
 854:	13 e0       	ldi	r17, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
 856:	1e 8b       	std	Y+22, r17	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 858:	5e 01       	movw	r10, r28
 85a:	b2 e0       	ldi	r27, 0x02	; 2
 85c:	ab 0e       	add	r10, r27
 85e:	b1 1c       	adc	r11, r1
 860:	c5 01       	movw	r24, r10
 862:	0e 94 f3 01 	call	0x3e6	; 0x3e6 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 866:	ce 01       	movw	r24, r28
 868:	0c 96       	adiw	r24, 0x0c	; 12
 86a:	0e 94 f3 01 	call	0x3e6	; 0x3e6 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 86e:	d9 87       	std	Y+9, r29	; 0x09
 870:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 872:	84 e0       	ldi	r24, 0x04	; 4
 874:	90 e0       	ldi	r25, 0x00	; 0
 876:	81 1b       	sub	r24, r17
 878:	91 09       	sbc	r25, r1
 87a:	9d 87       	std	Y+13, r25	; 0x0d
 87c:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 87e:	db 8b       	std	Y+19, r29	; 0x13
 880:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
 882:	19 a2       	std	Y+33, r1	; 0x21
 884:	1a a2       	std	Y+34, r1	; 0x22
 886:	1b a2       	std	Y+35, r1	; 0x23
 888:	1c a2       	std	Y+36, r1	; 0x24
		pxTCB->eNotifyState = eNotWaitingNotification;
 88a:	1d a2       	std	Y+37, r1	; 0x25
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 88c:	a3 01       	movw	r20, r6
 88e:	b4 01       	movw	r22, r8
 890:	c6 01       	movw	r24, r12
 892:	0e 94 3e 02 	call	0x47c	; 0x47c <pxPortInitialiseStack>
 896:	99 83       	std	Y+1, r25	; 0x01
 898:	88 83       	st	Y, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
 89a:	e1 14       	cp	r14, r1
 89c:	f1 04       	cpc	r15, r1
 89e:	19 f0       	breq	.+6      	; 0x8a6 <__stack+0x47>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8a0:	f7 01       	movw	r30, r14
 8a2:	d1 83       	std	Z+1, r29	; 0x01
 8a4:	c0 83       	st	Z, r28
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
 8a6:	0f b6       	in	r0, 0x3f	; 63
 8a8:	f8 94       	cli
 8aa:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
 8ac:	80 91 be 02 	lds	r24, 0x02BE
 8b0:	8f 5f       	subi	r24, 0xFF	; 255
 8b2:	80 93 be 02 	sts	0x02BE, r24
			if( pxCurrentTCB == NULL )
 8b6:	80 91 c4 02 	lds	r24, 0x02C4
 8ba:	90 91 c5 02 	lds	r25, 0x02C5
 8be:	89 2b       	or	r24, r25
 8c0:	e1 f5       	brne	.+120    	; 0x93a <__stack+0xdb>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
 8c2:	d0 93 c5 02 	sts	0x02C5, r29
 8c6:	c0 93 c4 02 	sts	0x02C4, r28

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8ca:	80 91 be 02 	lds	r24, 0x02BE
 8ce:	81 30       	cpi	r24, 0x01	; 1
 8d0:	09 f0       	breq	.+2      	; 0x8d4 <__stack+0x75>
 8d2:	42 c0       	rjmp	.+132    	; 0x958 <__stack+0xf9>
 8d4:	e1 2c       	mov	r14, r1
 8d6:	f1 2c       	mov	r15, r1
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8d8:	c7 01       	movw	r24, r14
 8da:	88 0f       	add	r24, r24
 8dc:	99 1f       	adc	r25, r25
 8de:	88 0f       	add	r24, r24
 8e0:	99 1f       	adc	r25, r25
 8e2:	88 0f       	add	r24, r24
 8e4:	99 1f       	adc	r25, r25
 8e6:	8e 0d       	add	r24, r14
 8e8:	9f 1d       	adc	r25, r15
 8ea:	89 53       	subi	r24, 0x39	; 57
 8ec:	9d 4f       	sbci	r25, 0xFD	; 253
 8ee:	0e 94 e5 01 	call	0x3ca	; 0x3ca <vListInitialise>
 8f2:	ff ef       	ldi	r31, 0xFF	; 255
 8f4:	ef 1a       	sub	r14, r31
 8f6:	ff 0a       	sbc	r15, r31

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8f8:	84 e0       	ldi	r24, 0x04	; 4
 8fa:	e8 16       	cp	r14, r24
 8fc:	f1 04       	cpc	r15, r1
 8fe:	61 f7       	brne	.-40     	; 0x8d8 <__stack+0x79>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
 900:	8b ee       	ldi	r24, 0xEB	; 235
 902:	92 e0       	ldi	r25, 0x02	; 2
 904:	0e 94 e5 01 	call	0x3ca	; 0x3ca <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 908:	84 ef       	ldi	r24, 0xF4	; 244
 90a:	92 e0       	ldi	r25, 0x02	; 2
 90c:	0e 94 e5 01 	call	0x3ca	; 0x3ca <vListInitialise>
	vListInitialise( &xPendingReadyList );
 910:	8d ef       	ldi	r24, 0xFD	; 253
 912:	92 e0       	ldi	r25, 0x02	; 2
 914:	0e 94 e5 01 	call	0x3ca	; 0x3ca <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
 918:	86 e0       	ldi	r24, 0x06	; 6
 91a:	93 e0       	ldi	r25, 0x03	; 3
 91c:	0e 94 e5 01 	call	0x3ca	; 0x3ca <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 920:	8b ee       	ldi	r24, 0xEB	; 235
 922:	92 e0       	ldi	r25, 0x02	; 2
 924:	90 93 c3 02 	sts	0x02C3, r25
 928:	80 93 c2 02 	sts	0x02C2, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 92c:	84 ef       	ldi	r24, 0xF4	; 244
 92e:	92 e0       	ldi	r25, 0x02	; 2
 930:	90 93 c1 02 	sts	0x02C1, r25
 934:	80 93 c0 02 	sts	0x02C0, r24
 938:	0f c0       	rjmp	.+30     	; 0x958 <__stack+0xf9>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
 93a:	80 91 ba 02 	lds	r24, 0x02BA
 93e:	81 11       	cpse	r24, r1
 940:	0b c0       	rjmp	.+22     	; 0x958 <__stack+0xf9>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
 942:	e0 91 c4 02 	lds	r30, 0x02C4
 946:	f0 91 c5 02 	lds	r31, 0x02C5
 94a:	86 89       	ldd	r24, Z+22	; 0x16
 94c:	08 17       	cp	r16, r24
 94e:	20 f0       	brcs	.+8      	; 0x958 <__stack+0xf9>
					{
						pxCurrentTCB = pxNewTCB;
 950:	d0 93 c5 02 	sts	0x02C5, r29
 954:	c0 93 c4 02 	sts	0x02C4, r28
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
 958:	80 91 c6 02 	lds	r24, 0x02C6
 95c:	8f 5f       	subi	r24, 0xFF	; 255
 95e:	80 93 c6 02 	sts	0x02C6, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
 962:	8e 89       	ldd	r24, Y+22	; 0x16
 964:	90 91 bb 02 	lds	r25, 0x02BB
 968:	98 17       	cp	r25, r24
 96a:	10 f4       	brcc	.+4      	; 0x970 <__stack+0x111>
 96c:	80 93 bb 02 	sts	0x02BB, r24
 970:	90 e0       	ldi	r25, 0x00	; 0
 972:	9c 01       	movw	r18, r24
 974:	22 0f       	add	r18, r18
 976:	33 1f       	adc	r19, r19
 978:	22 0f       	add	r18, r18
 97a:	33 1f       	adc	r19, r19
 97c:	22 0f       	add	r18, r18
 97e:	33 1f       	adc	r19, r19
 980:	82 0f       	add	r24, r18
 982:	93 1f       	adc	r25, r19
 984:	b5 01       	movw	r22, r10
 986:	89 53       	subi	r24, 0x39	; 57
 988:	9d 4f       	sbci	r25, 0xFD	; 253
 98a:	0e 94 f7 01 	call	0x3ee	; 0x3ee <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
 98e:	0f 90       	pop	r0
 990:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
 992:	80 91 ba 02 	lds	r24, 0x02BA
 996:	88 23       	and	r24, r24
 998:	59 f0       	breq	.+22     	; 0x9b0 <__stack+0x151>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
 99a:	e0 91 c4 02 	lds	r30, 0x02C4
 99e:	f0 91 c5 02 	lds	r31, 0x02C5
 9a2:	86 89       	ldd	r24, Z+22	; 0x16
 9a4:	80 17       	cp	r24, r16
 9a6:	30 f4       	brcc	.+12     	; 0x9b4 <__stack+0x155>
			{
				taskYIELD_IF_USING_PREEMPTION();
 9a8:	0e 94 07 03 	call	0x60e	; 0x60e <vPortYield>
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );

			xReturn = pdPASS;
 9ac:	81 e0       	ldi	r24, 0x01	; 1
 9ae:	05 c0       	rjmp	.+10     	; 0x9ba <__stack+0x15b>
 9b0:	81 e0       	ldi	r24, 0x01	; 1
 9b2:	03 c0       	rjmp	.+6      	; 0x9ba <__stack+0x15b>
 9b4:	81 e0       	ldi	r24, 0x01	; 1
 9b6:	01 c0       	rjmp	.+2      	; 0x9ba <__stack+0x15b>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 9b8:	8f ef       	ldi	r24, 0xFF	; 255
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
}
 9ba:	df 91       	pop	r29
 9bc:	cf 91       	pop	r28
 9be:	1f 91       	pop	r17
 9c0:	0f 91       	pop	r16
 9c2:	ff 90       	pop	r15
 9c4:	ef 90       	pop	r14
 9c6:	df 90       	pop	r13
 9c8:	cf 90       	pop	r12
 9ca:	bf 90       	pop	r11
 9cc:	af 90       	pop	r10
 9ce:	9f 90       	pop	r9
 9d0:	8f 90       	pop	r8
 9d2:	7f 90       	pop	r7
 9d4:	6f 90       	pop	r6
 9d6:	5f 90       	pop	r5
 9d8:	4f 90       	pop	r4
 9da:	08 95       	ret

000009dc <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 9dc:	af 92       	push	r10
 9de:	bf 92       	push	r11
 9e0:	cf 92       	push	r12
 9e2:	df 92       	push	r13
 9e4:	ef 92       	push	r14
 9e6:	ff 92       	push	r15
 9e8:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
 9ea:	a1 2c       	mov	r10, r1
 9ec:	b1 2c       	mov	r11, r1
 9ee:	c1 2c       	mov	r12, r1
 9f0:	d1 2c       	mov	r13, r1
 9f2:	e1 2c       	mov	r14, r1
 9f4:	f1 2c       	mov	r15, r1
 9f6:	00 e0       	ldi	r16, 0x00	; 0
 9f8:	20 e0       	ldi	r18, 0x00	; 0
 9fa:	30 e0       	ldi	r19, 0x00	; 0
 9fc:	44 e6       	ldi	r20, 0x64	; 100
 9fe:	50 e0       	ldi	r21, 0x00	; 0
 a00:	6f ea       	ldi	r22, 0xAF	; 175
 a02:	70 e0       	ldi	r23, 0x00	; 0
 a04:	86 e6       	ldi	r24, 0x66	; 102
 a06:	96 e0       	ldi	r25, 0x06	; 6
 a08:	0e 94 de 03 	call	0x7bc	; 0x7bc <xTaskGenericCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 a0c:	81 30       	cpi	r24, 0x01	; 1
 a0e:	81 f4       	brne	.+32     	; 0xa30 <vTaskStartScheduler+0x54>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
 a10:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
 a12:	8f ef       	ldi	r24, 0xFF	; 255
 a14:	9f ef       	ldi	r25, 0xFF	; 255
 a16:	90 93 b6 02 	sts	0x02B6, r25
 a1a:	80 93 b5 02 	sts	0x02B5, r24
		xSchedulerRunning = pdTRUE;
 a1e:	81 e0       	ldi	r24, 0x01	; 1
 a20:	80 93 ba 02 	sts	0x02BA, r24
		xTickCount = ( TickType_t ) 0U;
 a24:	10 92 bd 02 	sts	0x02BD, r1
 a28:	10 92 bc 02 	sts	0x02BC, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 a2c:	0e 94 d2 02 	call	0x5a4	; 0x5a4 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
 a30:	0f 91       	pop	r16
 a32:	ff 90       	pop	r15
 a34:	ef 90       	pop	r14
 a36:	df 90       	pop	r13
 a38:	cf 90       	pop	r12
 a3a:	bf 90       	pop	r11
 a3c:	af 90       	pop	r10
 a3e:	08 95       	ret

00000a40 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 a40:	80 91 b4 02 	lds	r24, 0x02B4
 a44:	8f 5f       	subi	r24, 0xFF	; 255
 a46:	80 93 b4 02 	sts	0x02B4, r24
 a4a:	08 95       	ret

00000a4c <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 a4c:	cf 92       	push	r12
 a4e:	df 92       	push	r13
 a50:	ef 92       	push	r14
 a52:	ff 92       	push	r15
 a54:	0f 93       	push	r16
 a56:	1f 93       	push	r17
 a58:	cf 93       	push	r28
 a5a:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 a5c:	80 91 b4 02 	lds	r24, 0x02B4
 a60:	81 11       	cpse	r24, r1
 a62:	9a c0       	rjmp	.+308    	; 0xb98 <xTaskIncrementTick+0x14c>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
 a64:	80 91 bc 02 	lds	r24, 0x02BC
 a68:	90 91 bd 02 	lds	r25, 0x02BD
 a6c:	01 96       	adiw	r24, 0x01	; 1
 a6e:	90 93 bd 02 	sts	0x02BD, r25
 a72:	80 93 bc 02 	sts	0x02BC, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
 a76:	e0 90 bc 02 	lds	r14, 0x02BC
 a7a:	f0 90 bd 02 	lds	r15, 0x02BD

			if( xConstTickCount == ( TickType_t ) 0U )
 a7e:	e1 14       	cp	r14, r1
 a80:	f1 04       	cpc	r15, r1
 a82:	b9 f4       	brne	.+46     	; 0xab2 <xTaskIncrementTick+0x66>
			{
				taskSWITCH_DELAYED_LISTS();
 a84:	80 91 c2 02 	lds	r24, 0x02C2
 a88:	90 91 c3 02 	lds	r25, 0x02C3
 a8c:	20 91 c0 02 	lds	r18, 0x02C0
 a90:	30 91 c1 02 	lds	r19, 0x02C1
 a94:	30 93 c3 02 	sts	0x02C3, r19
 a98:	20 93 c2 02 	sts	0x02C2, r18
 a9c:	90 93 c1 02 	sts	0x02C1, r25
 aa0:	80 93 c0 02 	sts	0x02C0, r24
 aa4:	80 91 b7 02 	lds	r24, 0x02B7
 aa8:	8f 5f       	subi	r24, 0xFF	; 255
 aaa:	80 93 b7 02 	sts	0x02B7, r24
 aae:	0e 94 bf 03 	call	0x77e	; 0x77e <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
 ab2:	80 91 b5 02 	lds	r24, 0x02B5
 ab6:	90 91 b6 02 	lds	r25, 0x02B6
 aba:	e8 16       	cp	r14, r24
 abc:	f9 06       	cpc	r15, r25
 abe:	20 f4       	brcc	.+8      	; 0xac8 <xTaskIncrementTick+0x7c>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 ac0:	d1 2c       	mov	r13, r1
 ac2:	54 c0       	rjmp	.+168    	; 0xb6c <xTaskIncrementTick+0x120>
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
							{
								xSwitchRequired = pdTRUE;
 ac4:	dc 2c       	mov	r13, r12
 ac6:	03 c0       	rjmp	.+6      	; 0xace <xTaskIncrementTick+0x82>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
 ac8:	d1 2c       	mov	r13, r1
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
							{
								xSwitchRequired = pdTRUE;
 aca:	cc 24       	eor	r12, r12
 acc:	c3 94       	inc	r12
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 ace:	e0 91 c2 02 	lds	r30, 0x02C2
 ad2:	f0 91 c3 02 	lds	r31, 0x02C3
 ad6:	80 81       	ld	r24, Z
 ad8:	81 11       	cpse	r24, r1
 ada:	07 c0       	rjmp	.+14     	; 0xaea <xTaskIncrementTick+0x9e>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
 adc:	8f ef       	ldi	r24, 0xFF	; 255
 ade:	9f ef       	ldi	r25, 0xFF	; 255
 ae0:	90 93 b6 02 	sts	0x02B6, r25
 ae4:	80 93 b5 02 	sts	0x02B5, r24
						break;
 ae8:	41 c0       	rjmp	.+130    	; 0xb6c <xTaskIncrementTick+0x120>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 aea:	e0 91 c2 02 	lds	r30, 0x02C2
 aee:	f0 91 c3 02 	lds	r31, 0x02C3
 af2:	05 80       	ldd	r0, Z+5	; 0x05
 af4:	f6 81       	ldd	r31, Z+6	; 0x06
 af6:	e0 2d       	mov	r30, r0
 af8:	c6 81       	ldd	r28, Z+6	; 0x06
 afa:	d7 81       	ldd	r29, Z+7	; 0x07
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 afc:	2a 81       	ldd	r18, Y+2	; 0x02
 afe:	3b 81       	ldd	r19, Y+3	; 0x03

						if( xConstTickCount < xItemValue )
 b00:	e2 16       	cp	r14, r18
 b02:	f3 06       	cpc	r15, r19
 b04:	28 f4       	brcc	.+10     	; 0xb10 <xTaskIncrementTick+0xc4>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
 b06:	30 93 b6 02 	sts	0x02B6, r19
 b0a:	20 93 b5 02 	sts	0x02B5, r18
							break;
 b0e:	2e c0       	rjmp	.+92     	; 0xb6c <xTaskIncrementTick+0x120>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 b10:	8e 01       	movw	r16, r28
 b12:	0e 5f       	subi	r16, 0xFE	; 254
 b14:	1f 4f       	sbci	r17, 0xFF	; 255
 b16:	c8 01       	movw	r24, r16
 b18:	0e 94 18 02 	call	0x430	; 0x430 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 b1c:	8c 89       	ldd	r24, Y+20	; 0x14
 b1e:	9d 89       	ldd	r25, Y+21	; 0x15
 b20:	89 2b       	or	r24, r25
 b22:	21 f0       	breq	.+8      	; 0xb2c <xTaskIncrementTick+0xe0>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 b24:	ce 01       	movw	r24, r28
 b26:	0c 96       	adiw	r24, 0x0c	; 12
 b28:	0e 94 18 02 	call	0x430	; 0x430 <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
 b2c:	2e 89       	ldd	r18, Y+22	; 0x16
 b2e:	80 91 bb 02 	lds	r24, 0x02BB
 b32:	82 17       	cp	r24, r18
 b34:	10 f4       	brcc	.+4      	; 0xb3a <xTaskIncrementTick+0xee>
 b36:	20 93 bb 02 	sts	0x02BB, r18
 b3a:	30 e0       	ldi	r19, 0x00	; 0
 b3c:	c9 01       	movw	r24, r18
 b3e:	88 0f       	add	r24, r24
 b40:	99 1f       	adc	r25, r25
 b42:	88 0f       	add	r24, r24
 b44:	99 1f       	adc	r25, r25
 b46:	88 0f       	add	r24, r24
 b48:	99 1f       	adc	r25, r25
 b4a:	82 0f       	add	r24, r18
 b4c:	93 1f       	adc	r25, r19
 b4e:	b8 01       	movw	r22, r16
 b50:	89 53       	subi	r24, 0x39	; 57
 b52:	9d 4f       	sbci	r25, 0xFD	; 253
 b54:	0e 94 f7 01 	call	0x3ee	; 0x3ee <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 b58:	e0 91 c4 02 	lds	r30, 0x02C4
 b5c:	f0 91 c5 02 	lds	r31, 0x02C5
 b60:	9e 89       	ldd	r25, Y+22	; 0x16
 b62:	86 89       	ldd	r24, Z+22	; 0x16
 b64:	98 17       	cp	r25, r24
 b66:	08 f0       	brcs	.+2      	; 0xb6a <xTaskIncrementTick+0x11e>
 b68:	ad cf       	rjmp	.-166    	; 0xac4 <xTaskIncrementTick+0x78>
 b6a:	b1 cf       	rjmp	.-158    	; 0xace <xTaskIncrementTick+0x82>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 b6c:	e0 91 c4 02 	lds	r30, 0x02C4
 b70:	f0 91 c5 02 	lds	r31, 0x02C5
 b74:	86 89       	ldd	r24, Z+22	; 0x16
 b76:	90 e0       	ldi	r25, 0x00	; 0
 b78:	fc 01       	movw	r30, r24
 b7a:	ee 0f       	add	r30, r30
 b7c:	ff 1f       	adc	r31, r31
 b7e:	ee 0f       	add	r30, r30
 b80:	ff 1f       	adc	r31, r31
 b82:	ee 0f       	add	r30, r30
 b84:	ff 1f       	adc	r31, r31
 b86:	8e 0f       	add	r24, r30
 b88:	9f 1f       	adc	r25, r31
 b8a:	fc 01       	movw	r30, r24
 b8c:	e9 53       	subi	r30, 0x39	; 57
 b8e:	fd 4f       	sbci	r31, 0xFD	; 253
 b90:	80 81       	ld	r24, Z
 b92:	82 30       	cpi	r24, 0x02	; 2
 b94:	40 f4       	brcc	.+16     	; 0xba6 <xTaskIncrementTick+0x15a>
 b96:	09 c0       	rjmp	.+18     	; 0xbaa <xTaskIncrementTick+0x15e>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
 b98:	80 91 b9 02 	lds	r24, 0x02B9
 b9c:	8f 5f       	subi	r24, 0xFF	; 255
 b9e:	80 93 b9 02 	sts	0x02B9, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 ba2:	d1 2c       	mov	r13, r1
 ba4:	02 c0       	rjmp	.+4      	; 0xbaa <xTaskIncrementTick+0x15e>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
 ba6:	dd 24       	eor	r13, r13
 ba8:	d3 94       	inc	r13
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
 baa:	80 91 b8 02 	lds	r24, 0x02B8
 bae:	88 23       	and	r24, r24
 bb0:	11 f0       	breq	.+4      	; 0xbb6 <xTaskIncrementTick+0x16a>
		{
			xSwitchRequired = pdTRUE;
 bb2:	dd 24       	eor	r13, r13
 bb4:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
 bb6:	8d 2d       	mov	r24, r13
 bb8:	df 91       	pop	r29
 bba:	cf 91       	pop	r28
 bbc:	1f 91       	pop	r17
 bbe:	0f 91       	pop	r16
 bc0:	ff 90       	pop	r15
 bc2:	ef 90       	pop	r14
 bc4:	df 90       	pop	r13
 bc6:	cf 90       	pop	r12
 bc8:	08 95       	ret

00000bca <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 bca:	df 92       	push	r13
 bcc:	ef 92       	push	r14
 bce:	ff 92       	push	r15
 bd0:	0f 93       	push	r16
 bd2:	1f 93       	push	r17
 bd4:	cf 93       	push	r28
 bd6:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 bd8:	0f b6       	in	r0, 0x3f	; 63
 bda:	f8 94       	cli
 bdc:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
 bde:	80 91 b4 02 	lds	r24, 0x02B4
 be2:	81 50       	subi	r24, 0x01	; 1
 be4:	80 93 b4 02 	sts	0x02B4, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 be8:	80 91 b4 02 	lds	r24, 0x02B4
 bec:	81 11       	cpse	r24, r1
 bee:	61 c0       	rjmp	.+194    	; 0xcb2 <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 bf0:	80 91 be 02 	lds	r24, 0x02BE
 bf4:	81 11       	cpse	r24, r1
 bf6:	32 c0       	rjmp	.+100    	; 0xc5c <xTaskResumeAll+0x92>
 bf8:	5f c0       	rjmp	.+190    	; 0xcb8 <xTaskResumeAll+0xee>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 bfa:	e0 91 02 03 	lds	r30, 0x0302
 bfe:	f0 91 03 03 	lds	r31, 0x0303
 c02:	c6 81       	ldd	r28, Z+6	; 0x06
 c04:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 c06:	ce 01       	movw	r24, r28
 c08:	0c 96       	adiw	r24, 0x0c	; 12
 c0a:	0e 94 18 02 	call	0x430	; 0x430 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 c0e:	8e 01       	movw	r16, r28
 c10:	0e 5f       	subi	r16, 0xFE	; 254
 c12:	1f 4f       	sbci	r17, 0xFF	; 255
 c14:	c8 01       	movw	r24, r16
 c16:	0e 94 18 02 	call	0x430	; 0x430 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 c1a:	8e 89       	ldd	r24, Y+22	; 0x16
 c1c:	90 91 bb 02 	lds	r25, 0x02BB
 c20:	98 17       	cp	r25, r24
 c22:	10 f4       	brcc	.+4      	; 0xc28 <xTaskResumeAll+0x5e>
 c24:	80 93 bb 02 	sts	0x02BB, r24
 c28:	90 e0       	ldi	r25, 0x00	; 0
 c2a:	9c 01       	movw	r18, r24
 c2c:	22 0f       	add	r18, r18
 c2e:	33 1f       	adc	r19, r19
 c30:	22 0f       	add	r18, r18
 c32:	33 1f       	adc	r19, r19
 c34:	22 0f       	add	r18, r18
 c36:	33 1f       	adc	r19, r19
 c38:	82 0f       	add	r24, r18
 c3a:	93 1f       	adc	r25, r19
 c3c:	b8 01       	movw	r22, r16
 c3e:	89 53       	subi	r24, 0x39	; 57
 c40:	9d 4f       	sbci	r25, 0xFD	; 253
 c42:	0e 94 f7 01 	call	0x3ee	; 0x3ee <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 c46:	e0 91 c4 02 	lds	r30, 0x02C4
 c4a:	f0 91 c5 02 	lds	r31, 0x02C5
 c4e:	9e 89       	ldd	r25, Y+22	; 0x16
 c50:	86 89       	ldd	r24, Z+22	; 0x16
 c52:	98 17       	cp	r25, r24
 c54:	58 f0       	brcs	.+22     	; 0xc6c <xTaskResumeAll+0xa2>
					{
						xYieldPending = pdTRUE;
 c56:	d0 92 b8 02 	sts	0x02B8, r13
 c5a:	08 c0       	rjmp	.+16     	; 0xc6c <xTaskResumeAll+0xa2>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 c5c:	0f 2e       	mov	r0, r31
 c5e:	fd ef       	ldi	r31, 0xFD	; 253
 c60:	ef 2e       	mov	r14, r31
 c62:	f2 e0       	ldi	r31, 0x02	; 2
 c64:	ff 2e       	mov	r15, r31
 c66:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
 c68:	dd 24       	eor	r13, r13
 c6a:	d3 94       	inc	r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 c6c:	f7 01       	movw	r30, r14
 c6e:	80 81       	ld	r24, Z
 c70:	81 11       	cpse	r24, r1
 c72:	c3 cf       	rjmp	.-122    	; 0xbfa <xTaskResumeAll+0x30>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
 c74:	80 91 b9 02 	lds	r24, 0x02B9
 c78:	88 23       	and	r24, r24
 c7a:	99 f0       	breq	.+38     	; 0xca2 <xTaskResumeAll+0xd8>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
 c7c:	80 91 b9 02 	lds	r24, 0x02B9
 c80:	88 23       	and	r24, r24
 c82:	79 f0       	breq	.+30     	; 0xca2 <xTaskResumeAll+0xd8>
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
 c84:	c1 e0       	ldi	r28, 0x01	; 1
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
 c86:	0e 94 26 05 	call	0xa4c	; 0xa4c <xTaskIncrementTick>
 c8a:	81 11       	cpse	r24, r1
						{
							xYieldPending = pdTRUE;
 c8c:	c0 93 b8 02 	sts	0x02B8, r28
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
 c90:	80 91 b9 02 	lds	r24, 0x02B9
 c94:	81 50       	subi	r24, 0x01	; 1
 c96:	80 93 b9 02 	sts	0x02B9, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
 c9a:	80 91 b9 02 	lds	r24, 0x02B9
 c9e:	81 11       	cpse	r24, r1
 ca0:	f2 cf       	rjmp	.-28     	; 0xc86 <xTaskResumeAll+0xbc>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
 ca2:	80 91 b8 02 	lds	r24, 0x02B8
 ca6:	81 30       	cpi	r24, 0x01	; 1
 ca8:	31 f4       	brne	.+12     	; 0xcb6 <xTaskResumeAll+0xec>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
 caa:	0e 94 07 03 	call	0x60e	; 0x60e <vPortYield>

				if( xYieldPending == pdTRUE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
 cae:	81 e0       	ldi	r24, 0x01	; 1
 cb0:	03 c0       	rjmp	.+6      	; 0xcb8 <xTaskResumeAll+0xee>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
 cb2:	80 e0       	ldi	r24, 0x00	; 0
 cb4:	01 c0       	rjmp	.+2      	; 0xcb8 <xTaskResumeAll+0xee>
 cb6:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 cb8:	0f 90       	pop	r0
 cba:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
 cbc:	df 91       	pop	r29
 cbe:	cf 91       	pop	r28
 cc0:	1f 91       	pop	r17
 cc2:	0f 91       	pop	r16
 cc4:	ff 90       	pop	r15
 cc6:	ef 90       	pop	r14
 cc8:	df 90       	pop	r13
 cca:	08 95       	ret

00000ccc <prvIdleTask>:
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 ccc:	c6 e0       	ldi	r28, 0x06	; 6
 cce:	d3 e0       	ldi	r29, 0x03	; 3

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 cd0:	0f 2e       	mov	r0, r31
 cd2:	f7 ec       	ldi	r31, 0xC7	; 199
 cd4:	ef 2e       	mov	r14, r31
 cd6:	f2 e0       	ldi	r31, 0x02	; 2
 cd8:	ff 2e       	mov	r15, r31
 cda:	f0 2d       	mov	r31, r0
 cdc:	28 c0       	rjmp	.+80     	; 0xd2e <prvIdleTask+0x62>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
 cde:	0e 94 20 05 	call	0xa40	; 0xa40 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 ce2:	18 81       	ld	r17, Y
			}
			( void ) xTaskResumeAll();
 ce4:	0e 94 e5 05 	call	0xbca	; 0xbca <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 ce8:	11 23       	and	r17, r17
 cea:	09 f1       	breq	.+66     	; 0xd2e <prvIdleTask+0x62>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
 cec:	0f b6       	in	r0, 0x3f	; 63
 cee:	f8 94       	cli
 cf0:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 cf2:	e0 91 0b 03 	lds	r30, 0x030B
 cf6:	f0 91 0c 03 	lds	r31, 0x030C
 cfa:	06 81       	ldd	r16, Z+6	; 0x06
 cfc:	17 81       	ldd	r17, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 cfe:	c8 01       	movw	r24, r16
 d00:	02 96       	adiw	r24, 0x02	; 2
 d02:	0e 94 18 02 	call	0x430	; 0x430 <uxListRemove>
					--uxCurrentNumberOfTasks;
 d06:	80 91 be 02 	lds	r24, 0x02BE
 d0a:	81 50       	subi	r24, 0x01	; 1
 d0c:	80 93 be 02 	sts	0x02BE, r24
					--uxTasksDeleted;
 d10:	80 91 bf 02 	lds	r24, 0x02BF
 d14:	81 50       	subi	r24, 0x01	; 1
 d16:	80 93 bf 02 	sts	0x02BF, r24
				}
				taskEXIT_CRITICAL();
 d1a:	0f 90       	pop	r0
 d1c:	0f be       	out	0x3f, r0	; 63
				vPortFreeAligned( pxTCB->pxStack );
			}
		}
		#else
		{
			vPortFreeAligned( pxTCB->pxStack );
 d1e:	f8 01       	movw	r30, r16
 d20:	87 89       	ldd	r24, Z+23	; 0x17
 d22:	90 8d       	ldd	r25, Z+24	; 0x18
 d24:	0e 94 b1 01 	call	0x362	; 0x362 <vPortFree>
		}
		#endif

		vPortFree( pxTCB );
 d28:	c8 01       	movw	r24, r16
 d2a:	0e 94 b1 01 	call	0x362	; 0x362 <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
 d2e:	80 91 bf 02 	lds	r24, 0x02BF
 d32:	81 11       	cpse	r24, r1
 d34:	d4 cf       	rjmp	.-88     	; 0xcde <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 d36:	f7 01       	movw	r30, r14
 d38:	80 81       	ld	r24, Z
 d3a:	82 30       	cpi	r24, 0x02	; 2
 d3c:	c0 f3       	brcs	.-16     	; 0xd2e <prvIdleTask+0x62>
			{
				taskYIELD();
 d3e:	0e 94 07 03 	call	0x60e	; 0x60e <vPortYield>
 d42:	f5 cf       	rjmp	.-22     	; 0xd2e <prvIdleTask+0x62>

00000d44 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 d44:	80 91 b4 02 	lds	r24, 0x02B4
 d48:	88 23       	and	r24, r24
 d4a:	21 f0       	breq	.+8      	; 0xd54 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 d4c:	81 e0       	ldi	r24, 0x01	; 1
 d4e:	80 93 b8 02 	sts	0x02B8, r24
 d52:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
 d54:	10 92 b8 02 	sts	0x02B8, r1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 d58:	80 91 bb 02 	lds	r24, 0x02BB
 d5c:	90 e0       	ldi	r25, 0x00	; 0
 d5e:	fc 01       	movw	r30, r24
 d60:	ee 0f       	add	r30, r30
 d62:	ff 1f       	adc	r31, r31
 d64:	ee 0f       	add	r30, r30
 d66:	ff 1f       	adc	r31, r31
 d68:	ee 0f       	add	r30, r30
 d6a:	ff 1f       	adc	r31, r31
 d6c:	8e 0f       	add	r24, r30
 d6e:	9f 1f       	adc	r25, r31
 d70:	fc 01       	movw	r30, r24
 d72:	e9 53       	subi	r30, 0x39	; 57
 d74:	fd 4f       	sbci	r31, 0xFD	; 253
 d76:	80 81       	ld	r24, Z
 d78:	81 11       	cpse	r24, r1
 d7a:	17 c0       	rjmp	.+46     	; 0xdaa <vTaskSwitchContext+0x66>
 d7c:	80 91 bb 02 	lds	r24, 0x02BB
 d80:	81 50       	subi	r24, 0x01	; 1
 d82:	80 93 bb 02 	sts	0x02BB, r24
 d86:	80 91 bb 02 	lds	r24, 0x02BB
 d8a:	90 e0       	ldi	r25, 0x00	; 0
 d8c:	fc 01       	movw	r30, r24
 d8e:	ee 0f       	add	r30, r30
 d90:	ff 1f       	adc	r31, r31
 d92:	ee 0f       	add	r30, r30
 d94:	ff 1f       	adc	r31, r31
 d96:	ee 0f       	add	r30, r30
 d98:	ff 1f       	adc	r31, r31
 d9a:	8e 0f       	add	r24, r30
 d9c:	9f 1f       	adc	r25, r31
 d9e:	fc 01       	movw	r30, r24
 da0:	e9 53       	subi	r30, 0x39	; 57
 da2:	fd 4f       	sbci	r31, 0xFD	; 253
 da4:	80 81       	ld	r24, Z
 da6:	88 23       	and	r24, r24
 da8:	49 f3       	breq	.-46     	; 0xd7c <vTaskSwitchContext+0x38>
 daa:	e0 91 bb 02 	lds	r30, 0x02BB
 dae:	f0 e0       	ldi	r31, 0x00	; 0
 db0:	cf 01       	movw	r24, r30
 db2:	88 0f       	add	r24, r24
 db4:	99 1f       	adc	r25, r25
 db6:	88 0f       	add	r24, r24
 db8:	99 1f       	adc	r25, r25
 dba:	88 0f       	add	r24, r24
 dbc:	99 1f       	adc	r25, r25
 dbe:	e8 0f       	add	r30, r24
 dc0:	f9 1f       	adc	r31, r25
 dc2:	e9 53       	subi	r30, 0x39	; 57
 dc4:	fd 4f       	sbci	r31, 0xFD	; 253
 dc6:	a1 81       	ldd	r26, Z+1	; 0x01
 dc8:	b2 81       	ldd	r27, Z+2	; 0x02
 dca:	12 96       	adiw	r26, 0x02	; 2
 dcc:	0d 90       	ld	r0, X+
 dce:	bc 91       	ld	r27, X
 dd0:	a0 2d       	mov	r26, r0
 dd2:	b2 83       	std	Z+2, r27	; 0x02
 dd4:	a1 83       	std	Z+1, r26	; 0x01
 dd6:	cf 01       	movw	r24, r30
 dd8:	03 96       	adiw	r24, 0x03	; 3
 dda:	a8 17       	cp	r26, r24
 ddc:	b9 07       	cpc	r27, r25
 dde:	31 f4       	brne	.+12     	; 0xdec <vTaskSwitchContext+0xa8>
 de0:	12 96       	adiw	r26, 0x02	; 2
 de2:	8d 91       	ld	r24, X+
 de4:	9c 91       	ld	r25, X
 de6:	13 97       	sbiw	r26, 0x03	; 3
 de8:	92 83       	std	Z+2, r25	; 0x02
 dea:	81 83       	std	Z+1, r24	; 0x01
 dec:	01 80       	ldd	r0, Z+1	; 0x01
 dee:	f2 81       	ldd	r31, Z+2	; 0x02
 df0:	e0 2d       	mov	r30, r0
 df2:	86 81       	ldd	r24, Z+6	; 0x06
 df4:	97 81       	ldd	r25, Z+7	; 0x07
 df6:	90 93 c5 02 	sts	0x02C5, r25
 dfa:	80 93 c4 02 	sts	0x02C4, r24
 dfe:	08 95       	ret

00000e00 <_exit>:
 e00:	f8 94       	cli

00000e02 <__stop_program>:
 e02:	ff cf       	rjmp	.-2      	; 0xe02 <__stop_program>
